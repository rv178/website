<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Hyperbola Quintessence in Rust | rv178</title><meta name=keywords content="rust,chess,chess engine,bitboards"><meta name=description content="Welcome to my dev-blog series on writing a chess engine. This is part 3. Like always, suggestions are welcome!
Hyperbola quintessence? This is the definition from chessprogramming.org:
Hyperbola Quintessence applies the o^(o-2r)-trick also for vertical or diagonal negative Rays - by reversing the bit-order of up to one bit per rank or byte with a vertical flip aka x86-64 bswap.
Why did I go for this approach? Because I thought magic bitboards were too hard for me."><meta name=author content><link rel=canonical href=https://rv178.is-a.dev/posts/hyperbola-quintessence-in-rust/><link crossorigin=anonymous href=/assets/css/stylesheet.29a7535ae3148c25cfd9661c085d5568afc290dd9abd041803f5964043035889.css integrity="sha256-KadTWuMUjCXP2WYcCF1VaK/CkN2avQQYA/WWQEMDWIk=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://raw.githubusercontent.com/rv178/website/main/static/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/rv178/website/main/static/favicon.png><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/rv178/website/main/static/favicon.png><link rel=apple-touch-icon href=https://raw.githubusercontent.com/rv178/website/main/static/favicon.png><link rel=mask-icon href=https://raw.githubusercontent.com/rv178/website/main/static/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Hyperbola Quintessence in Rust"><meta property="og:description" content="Welcome to my dev-blog series on writing a chess engine. This is part 3. Like always, suggestions are welcome!
Hyperbola quintessence? This is the definition from chessprogramming.org:
Hyperbola Quintessence applies the o^(o-2r)-trick also for vertical or diagonal negative Rays - by reversing the bit-order of up to one bit per rank or byte with a vertical flip aka x86-64 bswap.
Why did I go for this approach? Because I thought magic bitboards were too hard for me."><meta property="og:type" content="article"><meta property="og:url" content="https://rv178.is-a.dev/posts/hyperbola-quintessence-in-rust/"><meta property="og:image" content="https://raw.githubusercontent.com/rv178/website/main/static/favicon.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-18T21:53:57+05:30"><meta property="article:modified_time" content="2022-10-18T21:53:57+05:30"><meta property="og:site_name" content="rv178"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://raw.githubusercontent.com/rv178/website/main/static/favicon.png"><meta name=twitter:title content="Hyperbola Quintessence in Rust"><meta name=twitter:description content="Welcome to my dev-blog series on writing a chess engine. This is part 3. Like always, suggestions are welcome!
Hyperbola quintessence? This is the definition from chessprogramming.org:
Hyperbola Quintessence applies the o^(o-2r)-trick also for vertical or diagonal negative Rays - by reversing the bit-order of up to one bit per rank or byte with a vertical flip aka x86-64 bswap.
Why did I go for this approach? Because I thought magic bitboards were too hard for me."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://rv178.is-a.dev/posts/"},{"@type":"ListItem","position":3,"name":"Hyperbola Quintessence in Rust","item":"https://rv178.is-a.dev/posts/hyperbola-quintessence-in-rust/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Hyperbola Quintessence in Rust","name":"Hyperbola Quintessence in Rust","description":"Welcome to my dev-blog series on writing a chess engine. This is part 3. Like always, suggestions are welcome!\nHyperbola quintessence? This is the definition from chessprogramming.org:\nHyperbola Quintessence applies the o^(o-2r)-trick also for vertical or diagonal negative Rays - by reversing the bit-order of up to one bit per rank or byte with a vertical flip aka x86-64 bswap.\nWhy did I go for this approach? Because I thought magic bitboards were too hard for me.","keywords":["rust","chess","chess engine","bitboards"],"articleBody":" Welcome to my dev-blog series on writing a chess engine. This is part 3. Like always, suggestions are welcome!\nHyperbola quintessence? This is the definition from chessprogramming.org:\nHyperbola Quintessence applies the o^(o-2r)-trick also for vertical or diagonal negative Rays - by reversing the bit-order of up to one bit per rank or byte with a vertical flip aka x86-64 bswap.\nWhy did I go for this approach? Because I thought magic bitboards were too hard for me.\nImplementation // hyperbola quintessence pub fn hyp_quint(sq: Square, occ: BitBoard, mask: u64) -\u003e BitBoard { let mut forward = occ.0 \u0026 mask; let mut reverse = forward.reverse_bits(); forward = forward.wrapping_sub(BitBoard::from_sq(sq).0); reverse = reverse.wrapping_sub(BitBoard::from_sq(sq).0.reverse_bits()); forward ^= reverse.reverse_bits(); forward \u0026= mask; BitBoard(forward) } Where sq is the square the piece is in, occ is the occupancy bitboard, and mask is the attack mask. Why use wrapping_sub() instead of the -= operator? I found that the code sometimes panics if the variable is out of bounds.\nAs I already covered in my previous blog:\n// to represent squares #[rustfmt::skip] #[derive(Copy, Clone, Debug, PartialEq, Eq)] enum Square { A8, B8, C8, D8, E8, F8, G8, H8, A7, B7, C7, D7, E7, F7, G7, H7, A6, B6, C6, D6, E6, F6, G6, H6, A5, B5, C5, D5, E5, F5, G5, H5, A4, B4, C4, D4, E4, F4, G4, H4, A3, B3, C3, D3, E3, F3, G3, H3, A2, B2, C2, D2, E2, F2, G2, H2, A1, B1, C1, D1, E1, F1, G1, H1, } Square is an enum. The occupancy bitboard gives us the occupied squares (where the rays are blocked). As for the mask, here’s an example:\nLet’s say we wish to get the attacks in one file. For this, let’s assume a rook is on E4:\nHex: 1000000000 Value: 68719476736 8 . . . . . . . . 7 . . . . . . . . 6 . . . . . . . . 5 . . . . . . . . 4 . . . . 1 . . . 3 . . . . . . . . 2 . . . . . . . . 1 . . . . . . . . a b c d e f g h And C4 and G4 are occupied:\nHex: 4400000000 Value: 292057776128 8 . . . . . . . . 7 . . . . . . . . 6 . . . . . . . . 5 . . . . . . . . 4 . . 1 . . . 1 . 3 . . . . . . . . 2 . . . . . . . . 1 . . . . . . . . a b c d e f g h Now the mask for generating attack on this specific rank would be a bitboard of the 4th rank. That is,\nHex: ff00000000 Value: 1095216660480 8 . . . . . . . . 7 . . . . . . . . 6 . . . . . . . . 5 . . . . . . . . 4 1 1 1 1 1 1 1 1 3 . . . . . . . . 2 . . . . . . . . 1 . . . . . . . . a b c d e f g h Now if we execute the hyperbola quintessence function on this, we get all possible attacks for the rook on the 4th rank.\nhyp_quint(Square::E4, r, RANKS[4].0).print(); Hex: 6c00000000 Value: 463856467968 8 . . . . . . . . 7 . . . . . . . . 6 . . . . . . . . 5 . . . . . . . . 4 . . 1 1 . 1 1 . 3 . . . . . . . . 2 . . . . . . . . 1 . . . . . . . . a b c d e f g h This is the intended bitboard denoting all possible rank-attacks of a rook on E4 with respect to the occupancy bitboard. Note that we also generate an attack on the blocked bits, as they can be captures (unless they’re friendly pieces).\nWe can do the same for generating rook attacks both vertically and horizontally.\npub fn rook(sq: Square, occ: BitBoard) -\u003e BitBoard { let tr = sq as usize / 8; let tf = sq as usize % 8; BitBoard(hyp_quint(sq, occ, FILES[tf].0).0 | hyp_quint(sq, occ, RANKS[tr].0).0) } Where tr is the target rank, and tf is the target file (for getting the value of file/rank mask).\npub const RANKS: [BitBoard; 8] = [ BitBoard(255), // 8th rank BitBoard(65280), // 7th rank BitBoard(16711680), // 6th rank BitBoard(4278190080), // 5th rank BitBoard(1095216660480), // 4th rank BitBoard(280375465082880), // 3rd rank BitBoard(71776119061217280), // 2nd rank BitBoard(18374686479671623680), // 1st rank ]; pub const FILES: [BitBoard; 8] = [ BitBoard(72340172838076673), // a file BitBoard(144680345676153346), // b file BitBoard(289360691352306692), // c file BitBoard(578721382704613384), // d file BitBoard(1157442765409226768), // e file BitBoard(2314885530818453536), // f file BitBoard(4629771061636907072), // g file BitBoard(9259542123273814144), // h file ]; For bishops, we can do the same but with diagonal and anti-diagonal masks.\n// diagonal masks pub const DIAG: [BitBoard; 15] = [ BitBoard(0x80), BitBoard(0x8040), BitBoard(0x804020), BitBoard(0x80402010), BitBoard(0x8040201008), BitBoard(0x804020100804), BitBoard(0x80402010080402), BitBoard(0x8040201008040201), BitBoard(0x4020100804020100), BitBoard(0x2010080402010000), BitBoard(0x1008040201000000), BitBoard(0x804020100000000), BitBoard(0x402010000000000), BitBoard(0x201000000000000), BitBoard(0x100000000000000), ]; // anti-diagonal masks pub const ANTI_DIAG: [BitBoard; 15] = [ BitBoard(0x1), BitBoard(0x102), BitBoard(0x10204), BitBoard(0x1020408), BitBoard(0x102040810), BitBoard(0x10204081020), BitBoard(0x1020408102040), BitBoard(0x102040810204080), BitBoard(0x204081020408000), BitBoard(0x408102040800000), BitBoard(0x810204080000000), BitBoard(0x1020408000000000), BitBoard(0x2040800000000000), BitBoard(0x4080000000000000), BitBoard(0x8000000000000000), ]; pub fn bishop(sq: Square, occ: BitBoard) -\u003e BitBoard { let tr = sq as usize / 8; let tf = sq as usize % 8; let diag_index: usize = 7 + tr - tf; let anti_diag_index: usize = tr + tf; BitBoard( hyp_quint(sq, occ, DIAG[diag_index].0).0 | hyp_quint(sq, occ, ANTI_DIAG[anti_diag_index].0).0, ) } And for generating queen attacks, it’s even easier since we can take the union of the bishop and rook attack bitboards:\npub fn queen(sq: Square, occ: BitBoard) -\u003e BitBoard { BitBoard(rook(sq, occ).0 | bishop(sq, occ).0) } That’s it for this blog, see you soon!\n","wordCount":"1022","inLanguage":"en","datePublished":"2022-10-18T21:53:57+05:30","dateModified":"2022-10-18T21:53:57+05:30","mainEntityOfPage":{"@type":"WebPage","@id":"https://rv178.is-a.dev/posts/hyperbola-quintessence-in-rust/"},"publisher":{"@type":"Organization","name":"rv178","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/rv178/website/main/static/favicon.png"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><ul id=menu><li><a href=https://rv178.is-a.dev/ title=Home><span>Home</span></a></li><li><a href=https://rv178.is-a.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://rv178.is-a.dev/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul><div class=logo><a href=https://rv178.is-a.dev accesskey=h title="  (Alt + H)"></a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://rv178.is-a.dev>Home</a>&nbsp;»&nbsp;<a href=https://rv178.is-a.dev/posts/>Posts</a></div><h1 class=post-title>Hyperbola Quintessence in Rust</h1><div class=post-meta><span title='2022-10-18 21:53:57 +0530 +0530'>October 18, 2022</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1022 words</div></header><div class=post-content><hr><p>Welcome to my dev-blog series on writing a chess engine. This is part 3. Like always, suggestions are welcome!</p><h3 id=hyperbola-quintessence>Hyperbola quintessence?<a hidden class=anchor aria-hidden=true href=#hyperbola-quintessence>#</a></h3><p>This is the definition from <a href=https://www.chessprogramming.org/Hyperbola_Quintessence>chessprogramming.org</a>:</p><blockquote><p>Hyperbola Quintessence applies the o^(o-2r)-trick also for vertical or diagonal negative Rays - by reversing the bit-order
of up to one bit per rank or byte with a vertical flip aka x86-64 bswap.</p></blockquote><p>Why did I go for this approach? Because I thought <a href=https://www.chessprogramming.org/Magic_Bitboards>magic bitboards</a> were too
hard for me.</p><h3 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// hyperbola quintessence
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>hyp_quint</span>(sq: <span style=color:#a6e22e>Square</span>, occ: <span style=color:#a6e22e>BitBoard</span>, mask: <span style=color:#66d9ef>u64</span>) -&gt; <span style=color:#a6e22e>BitBoard</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> forward <span style=color:#f92672>=</span> occ.<span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;</span> mask;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> reverse <span style=color:#f92672>=</span> forward.reverse_bits();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    forward <span style=color:#f92672>=</span> forward.wrapping_sub(BitBoard::from_sq(sq).<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    reverse <span style=color:#f92672>=</span> reverse.wrapping_sub(BitBoard::from_sq(sq).<span style=color:#ae81ff>0.</span>reverse_bits());
</span></span><span style=display:flex><span>    forward <span style=color:#f92672>^=</span> reverse.reverse_bits();
</span></span><span style=display:flex><span>    forward <span style=color:#f92672>&amp;=</span> mask;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    BitBoard(forward)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Where <code>sq</code> is the square the piece is in, <code>occ</code> is the occupancy bitboard, and <code>mask</code> is the attack mask. Why use <code>wrapping_sub()</code>
instead of the <code>-=</code> operator? I found that the code sometimes panics if the variable is out of bounds.</p><p>As I already covered in my previous blog:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// to represent squares
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[rustfmt::skip]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Copy, Clone, Debug, PartialEq, Eq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Square</span> {
</span></span><span style=display:flex><span>    A8, B8, C8, D8, E8, F8, G8, H8,
</span></span><span style=display:flex><span>    A7, B7, C7, D7, E7, F7, G7, H7,
</span></span><span style=display:flex><span>    A6, B6, C6, D6, E6, F6, G6, H6,
</span></span><span style=display:flex><span>    A5, B5, C5, D5, E5, F5, G5, H5,
</span></span><span style=display:flex><span>    A4, B4, C4, D4, E4, F4, G4, H4,
</span></span><span style=display:flex><span>    A3, B3, C3, D3, E3, F3, G3, H3,
</span></span><span style=display:flex><span>    A2, B2, C2, D2, E2, F2, G2, H2,
</span></span><span style=display:flex><span>    A1, B1, C1, D1, E1, F1, G1, H1,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Square is an enum. The occupancy bitboard gives us the occupied squares (where the rays are blocked). As for the mask, here&rsquo;s an
example:</p><p>Let&rsquo;s say we wish to get the attacks in one file. For this, let&rsquo;s assume a rook is on E4:</p><pre tabindex=0><code>Hex: 1000000000
Value: 68719476736

8  . . . . . . . . 
7  . . . . . . . . 
6  . . . . . . . . 
5  . . . . . . . . 
4  . . . . 1 . . . 
3  . . . . . . . . 
2  . . . . . . . . 
1  . . . . . . . . 

   a b c d e f g h
</code></pre><p>And C4 and G4 are occupied:</p><pre tabindex=0><code>
Hex: 4400000000
Value: 292057776128

8  . . . . . . . . 
7  . . . . . . . . 
6  . . . . . . . . 
5  . . . . . . . . 
4  . . 1 . . . 1 . 
3  . . . . . . . . 
2  . . . . . . . . 
1  . . . . . . . . 

   a b c d e f g h
</code></pre><p>Now the mask for generating attack on this specific rank would be a bitboard of the 4th rank. That is,</p><pre tabindex=0><code>
Hex: ff00000000
Value: 1095216660480

8  . . . . . . . . 
7  . . . . . . . . 
6  . . . . . . . . 
5  . . . . . . . . 
4  1 1 1 1 1 1 1 1 
3  . . . . . . . . 
2  . . . . . . . . 
1  . . . . . . . . 

   a b c d e f g h
</code></pre><p>Now if we execute the hyperbola quintessence function on this, we get all possible attacks for the rook on the 4th rank.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>hyp_quint(Square::E4, r, <span style=color:#66d9ef>RANKS</span>[<span style=color:#ae81ff>4</span>].<span style=color:#ae81ff>0</span>).print();
</span></span></code></pre></div><pre tabindex=0><code>Hex: 6c00000000
Value: 463856467968

8  . . . . . . . . 
7  . . . . . . . . 
6  . . . . . . . . 
5  . . . . . . . . 
4  . . 1 1 . 1 1 . 
3  . . . . . . . . 
2  . . . . . . . . 
1  . . . . . . . . 

   a b c d e f g h
</code></pre><p>This is the intended bitboard denoting all possible rank-attacks of a rook on E4 with respect to the occupancy bitboard. Note
that we also generate an attack on the blocked bits, as they can be captures (unless they&rsquo;re friendly pieces).</p><p>We can do the same for generating rook attacks both vertically and horizontally.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>rook</span>(sq: <span style=color:#a6e22e>Square</span>, occ: <span style=color:#a6e22e>BitBoard</span>) -&gt; <span style=color:#a6e22e>BitBoard</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> tr <span style=color:#f92672>=</span> sq <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> tf <span style=color:#f92672>=</span> sq <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span> <span style=color:#f92672>%</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    BitBoard(hyp_quint(sq, occ, <span style=color:#66d9ef>FILES</span>[tf].<span style=color:#ae81ff>0</span>).<span style=color:#ae81ff>0</span> <span style=color:#f92672>|</span> hyp_quint(sq, occ, <span style=color:#66d9ef>RANKS</span>[tr].<span style=color:#ae81ff>0</span>).<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Where <code>tr</code> is the target rank, and <code>tf</code> is the target file (for getting the value of file/rank mask).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>RANKS</span>: [BitBoard; <span style=color:#ae81ff>8</span>] <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>255</span>),                  <span style=color:#75715e>// 8th rank
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    BitBoard(<span style=color:#ae81ff>65280</span>),                <span style=color:#75715e>// 7th rank
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    BitBoard(<span style=color:#ae81ff>16711680</span>),             <span style=color:#75715e>// 6th rank
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    BitBoard(<span style=color:#ae81ff>4278190080</span>),           <span style=color:#75715e>// 5th rank
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    BitBoard(<span style=color:#ae81ff>1095216660480</span>),        <span style=color:#75715e>// 4th rank
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    BitBoard(<span style=color:#ae81ff>280375465082880</span>),      <span style=color:#75715e>// 3rd rank
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    BitBoard(<span style=color:#ae81ff>71776119061217280</span>),    <span style=color:#75715e>// 2nd rank
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    BitBoard(<span style=color:#ae81ff>18374686479671623680</span>), <span style=color:#75715e>// 1st rank
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>FILES</span>: [BitBoard; <span style=color:#ae81ff>8</span>] <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>72340172838076673</span>),   <span style=color:#75715e>// a file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    BitBoard(<span style=color:#ae81ff>144680345676153346</span>),  <span style=color:#75715e>// b file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    BitBoard(<span style=color:#ae81ff>289360691352306692</span>),  <span style=color:#75715e>// c file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    BitBoard(<span style=color:#ae81ff>578721382704613384</span>),  <span style=color:#75715e>// d file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    BitBoard(<span style=color:#ae81ff>1157442765409226768</span>), <span style=color:#75715e>// e file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    BitBoard(<span style=color:#ae81ff>2314885530818453536</span>), <span style=color:#75715e>// f file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    BitBoard(<span style=color:#ae81ff>4629771061636907072</span>), <span style=color:#75715e>// g file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    BitBoard(<span style=color:#ae81ff>9259542123273814144</span>), <span style=color:#75715e>// h file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>];
</span></span></code></pre></div><p>For bishops, we can do the same but with diagonal and anti-diagonal masks.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// diagonal masks
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>DIAG</span>: [BitBoard; <span style=color:#ae81ff>15</span>] <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x80</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x8040</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x804020</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x80402010</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x8040201008</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x804020100804</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x80402010080402</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x8040201008040201</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x4020100804020100</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x2010080402010000</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x1008040201000000</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x804020100000000</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x402010000000000</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x201000000000000</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x100000000000000</span>),
</span></span><span style=display:flex><span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// anti-diagonal masks
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>ANTI_DIAG</span>: [BitBoard; <span style=color:#ae81ff>15</span>] <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x1</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x102</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x10204</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x1020408</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x102040810</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x10204081020</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x1020408102040</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x102040810204080</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x204081020408000</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x408102040800000</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x810204080000000</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x1020408000000000</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x2040800000000000</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x4080000000000000</span>),
</span></span><span style=display:flex><span>    BitBoard(<span style=color:#ae81ff>0x8000000000000000</span>),
</span></span><span style=display:flex><span>];
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>bishop</span>(sq: <span style=color:#a6e22e>Square</span>, occ: <span style=color:#a6e22e>BitBoard</span>) -&gt; <span style=color:#a6e22e>BitBoard</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> tr <span style=color:#f92672>=</span> sq <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> tf <span style=color:#f92672>=</span> sq <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span> <span style=color:#f92672>%</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> diag_index: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span> <span style=color:#f92672>+</span> tr <span style=color:#f92672>-</span> tf;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> anti_diag_index: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> tr <span style=color:#f92672>+</span> tf;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    BitBoard(
</span></span><span style=display:flex><span>        hyp_quint(sq, occ, <span style=color:#66d9ef>DIAG</span>[diag_index].<span style=color:#ae81ff>0</span>).<span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>|</span> hyp_quint(sq, occ, <span style=color:#66d9ef>ANTI_DIAG</span>[anti_diag_index].<span style=color:#ae81ff>0</span>).<span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And for generating queen attacks, it&rsquo;s even easier since we can take the union of the bishop and rook attack bitboards:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>queen</span>(sq: <span style=color:#a6e22e>Square</span>, occ: <span style=color:#a6e22e>BitBoard</span>) -&gt; <span style=color:#a6e22e>BitBoard</span> {
</span></span><span style=display:flex><span>    BitBoard(rook(sq, occ).<span style=color:#ae81ff>0</span> <span style=color:#f92672>|</span> bishop(sq, occ).<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&rsquo;s it for this blog, see you soon!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://rv178.is-a.dev/tags/rust/>rust</a></li><li><a href=https://rv178.is-a.dev/tags/chess/>chess</a></li><li><a href=https://rv178.is-a.dev/tags/chess-engine/>chess-engine</a></li><li><a href=https://rv178.is-a.dev/tags/bitboards/>bitboards</a></li></ul><nav class=paginav><a class=next href=https://rv178.is-a.dev/posts/bitboards-in-rust/><span class=title>Next »</span><br><span>Bitboards in Rust</span></a></nav></footer></article></main><footer class=footer><span>Copyright &copy; 2025 <a href=https://rv178.is-a.dev>rv178</a></span>
<span>| <a href=https://github.com/rv178/website rel=noopener target=_blank>Source code</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>