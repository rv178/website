<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>FEN String Parsing in Rust | rv178</title><meta name=keywords content="fen,chess,rust"><meta name=description content="I finally finished the FEN string parsing part of my chess engine after days of procrastinating and I just wanted to share my experience with everyone.
So a FEN string looks like this:
rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 This is the FEN string of the starting position in standard chess. It looks like random crap at first glance but this string conveys a lot of information.
So let&rsquo;s divide it into parts."><meta name=author content><link rel=canonical href=https://rv178.is-a.dev/posts/fen-string-parsing-in-rust/><link crossorigin=anonymous href=/assets/css/stylesheet.29a7535ae3148c25cfd9661c085d5568afc290dd9abd041803f5964043035889.css integrity="sha256-KadTWuMUjCXP2WYcCF1VaK/CkN2avQQYA/WWQEMDWIk=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://raw.githubusercontent.com/rv178/website/main/static/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/rv178/website/main/static/favicon.png><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/rv178/website/main/static/favicon.png><link rel=apple-touch-icon href=https://raw.githubusercontent.com/rv178/website/main/static/favicon.png><link rel=mask-icon href=https://raw.githubusercontent.com/rv178/website/main/static/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="FEN String Parsing in Rust"><meta property="og:description" content="I finally finished the FEN string parsing part of my chess engine after days of procrastinating and I just wanted to share my experience with everyone.
So a FEN string looks like this:
rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 This is the FEN string of the starting position in standard chess. It looks like random crap at first glance but this string conveys a lot of information.
So let&rsquo;s divide it into parts."><meta property="og:type" content="article"><meta property="og:url" content="https://rv178.is-a.dev/posts/fen-string-parsing-in-rust/"><meta property="og:image" content="https://raw.githubusercontent.com/rv178/website/main/static/favicon.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-29T14:54:23+05:30"><meta property="article:modified_time" content="2022-06-29T14:54:23+05:30"><meta property="og:site_name" content="rv178"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://raw.githubusercontent.com/rv178/website/main/static/favicon.png"><meta name=twitter:title content="FEN String Parsing in Rust"><meta name=twitter:description content="I finally finished the FEN string parsing part of my chess engine after days of procrastinating and I just wanted to share my experience with everyone.
So a FEN string looks like this:
rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 This is the FEN string of the starting position in standard chess. It looks like random crap at first glance but this string conveys a lot of information.
So let&rsquo;s divide it into parts."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://rv178.is-a.dev/posts/"},{"@type":"ListItem","position":3,"name":"FEN String Parsing in Rust","item":"https://rv178.is-a.dev/posts/fen-string-parsing-in-rust/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"FEN String Parsing in Rust","name":"FEN String Parsing in Rust","description":"I finally finished the FEN string parsing part of my chess engine after days of procrastinating and I just wanted to share my experience with everyone.\nSo a FEN string looks like this:\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 This is the FEN string of the starting position in standard chess. It looks like random crap at first glance but this string conveys a lot of information.\nSo let\u0026rsquo;s divide it into parts.","keywords":["fen","chess","rust"],"articleBody":" I finally finished the FEN string parsing part of my chess engine after days of procrastinating and I just wanted to share my experience with everyone.\nSo a FEN string looks like this:\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 This is the FEN string of the starting position in standard chess. It looks like random crap at first glance but this string conveys a lot of information.\nSo letâ€™s divide it into parts.\nPieces The first part conveys information regarding piece placement. Each letter represents a piece on each rank of the board, and numbers denote empty spaces.\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR Letâ€™s look at an example from chess.com here:\nAs you can observe lower case characters are for black pieces and upper case characters are for white pieces.\nNow, moving on to the second part.\nSide to move The second part consists of just a letter which can either be b or w.\nHere we can observe that itâ€™s w.\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR | w | KQkq | - | 0 | 1 That means itâ€™s whiteâ€™s turn to move, and b means itâ€™s blackâ€™s turn to move.\nCastling ability The third part contains information regarding castling ability of both sides.\nK - White can castle kingside.\nk - Black can castle kingside.\nQ - White can castle queenside.\nq - Black can castle queenside.\nIf no sides can castle, - is used like so:\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w - - 0 1 En passant squares The next part gives us information if any en passant squares are possible. If there are no en passant squares, - is used as demonstrated in this example. If there are any, then the co-ordinates of that square is used.\nHalf move clock and full move counter The next two parts give us information regarding the number of halfmoves and fullmoves completed. Here you can observe the half move count is 0 and the full move count is 1.\nParsing the string To track the current game status, I made a struct called GameStatus.\npub struct GameStatus { pub pieces: Vec\u003cOption\u003cPiece\u003e\u003e, pub side_to_move: Colour, pub castling_id: [bool; 4], pub en_passant: Option\u003cVec\u003cSquare\u003e\u003e, pub half_move_clock: u32, pub full_move_count: u32, } What I wanted to do here was make functions for each variable and then assign it to the fields in the struct.\nFor parsing the side to move I first created an enumerator called Colour.\npub enum Colour { White, Black, Undefined, } White and Black are both sides, and undefined is used for error handling if the input is invalid.\nI then created a function that will return a value based on the input given. I really love rustâ€™s match syntax ðŸ˜„.\nfn active_side(input: \u0026str) -\u003e Colour { match input { \"w\" =\u003e Colour::White, \"b\" =\u003e Colour::Black, _ =\u003e Colour::Undefined, } } if colour == Colour::Undefined { println!(\"Invalid FEN string: Failed to parse active colour.\"); exit(1); } For parsing castling ability I decided to make an array of bools that would contain values corresponding to the info parsed from the string.\n[true, true, true, true] if input is KQkq (all sides can castle both ways).\nIndex 0 checks if the white king can castle kingside. ie, K and so on.\nIndex 1 =\u003e can white king castle queenside?\nIndex 2 =\u003e can black king castle kingside?\nIndex 3 =\u003e can black king castle queenside?\nSo I made a function that returns this array of bools.\nfn castling_ability(input: \u0026str) -\u003e [bool; 4] { if input == \"-\" { [false, false, false, false] } else { let mut castling_id = [false; 4]; let mut castling_id_str = input.to_string(); castling_id_str.retain(|c| c != '-'); for c in castling_id_str.chars() { match c { 'K' =\u003e castling_id[0] = true, 'Q' =\u003e castling_id[1] = true, 'k' =\u003e castling_id[2] = true, 'q' =\u003e castling_id[3] = true, _ =\u003e { println!(\"Invalid FEN string: Failed to parse castling ability.\"); exit(1); } } } castling_id } } For parsing en passant squares the solution I came up with was rather stupid.\nSince the input can either be - or multiple squares like e4e5g6 etc., I wanted a vector that contained each square.\nSo basically,\ne4e5g6 =\u003e [Square::E4, Square::E5, Square::G6]\n(Square is an enum, this change was made later. Check this blog for more info. Yes, I updated this blog :D)\nfn en_passant(input: \u0026str) -\u003e Option\u003cVec\u003cSquare\u003e\u003e { if input.chars().all(char::is_whitespace) | input.contains('-') { None } else { let chars = input.chars().collect::\u003cVec\u003cchar\u003e\u003e(); if chars.len() % 2 == 0 { let mut ep_vec = Vec::new(); let mut sq; for i in 0..chars.len() { if i % 2 == 0 { let valid_chars = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']; let mut invalid = true; for c in valid_chars.iter() { if chars[i] == *c { invalid = false; } } if i \u003c chars.len() - 1 { if !chars[i].is_alphabetic() | !chars[i + 1].is_numeric() { fen_log!(\"Invalid FEN string: Failed to parse en passant square.\"); exit(1); } if chars[i + 1] .to_digit(10) .expect(\"Could not parse character to digit (en passant)\") \u003e 8 { invalid = true; } } if invalid { fen_log!(\"Invalid FEN string: Failed to parse en passant square.\"); exit(1); } let file; match chars[i] { 'a' =\u003e file = 0, 'b' =\u003e file = 1, 'c' =\u003e file = 2, 'd' =\u003e file = 3, 'e' =\u003e file = 4, 'f' =\u003e file = 5, 'g' =\u003e file = 6, 'h' =\u003e file = 7, _ =\u003e { fen_log!(\"Invalid FEN string: Failed to parse en passant square.\"); exit(1); } } let rank; match chars[i + 1] { '1' =\u003e rank = 7, '2' =\u003e rank = 6, '3' =\u003e rank = 5, '4' =\u003e rank = 4, '5' =\u003e rank = 3, '6' =\u003e rank = 2, '7' =\u003e rank = 1, '8' =\u003e rank = 0, _ =\u003e { fen_log!(\"Invalid FEN string: Failed to parse en passant square.\"); exit(1); } } sq = rank * 8 + file; ep_vec.push(match_u32_to_sq(sq as u32)); } } Some(ep_vec) } else { fen_log!(\"Invalid FEN string: Failed to parse en passant square.\"); exit(1); } } } Parsing the halfmove and fullmove counts were rather easy, and I just had to return a u32 from the string input.\nfn halfmove_clock(input: \u0026str) -\u003e u32 { let mut halfmove_clock = String::new(); for c in input.chars() { if c.is_digit(10) { halfmove_clock.push(c); } } halfmove_clock.parse::\u003cu32\u003e().unwrap() } fn fullmove_count(input: \u0026str) -\u003e u32 { let mut fullmove_clock = String::new(); for c in input.chars() { if c.is_digit(10) { fullmove_clock.push(c); } } fullmove_clock.parse::\u003cu32\u003e().unwrap() } However for piece placement parsing, I saw a really good implementation of it in the fen crate so I decided to just joink it ðŸ˜”.\nThereâ€™s a struct called Piece that stores the type, colour and symbol (added by me to print out pieces in the board).\npub struct Piece { pub kind: Kind, pub colour: Colour, pub symbol: char, } And an enum Kind:\npub enum Kind { King, Queen, Bishop, Knight, Rook, Pawn, } And according to the input given, a value is returned that is later pushed to a vector.\nlet (color, kind, symbol) = match piece_char { 'P' =\u003e (Colour::White, Kind::Pawn, 'P'), 'N' =\u003e (Colour::White, Kind::Knight, 'N'), 'B' =\u003e (Colour::White, Kind::Bishop, 'B'), 'R' =\u003e (Colour::White, Kind::Rook, 'R'), 'Q' =\u003e (Colour::White, Kind::Queen, 'Q'), 'K' =\u003e (Colour::White, Kind::King, 'K'), 'p' =\u003e (Colour::Black, Kind::Pawn, 'p'), 'n' =\u003e (Colour::Black, Kind::Knight, 'n'), 'b' =\u003e (Colour::Black, Kind::Bishop, 'b'), 'r' =\u003e (Colour::Black, Kind::Rook, 'r'), 'q' =\u003e (Colour::Black, Kind::Queen, 'q'), 'k' =\u003e (Colour::Black, Kind::King, 'k'), _ =\u003e return None, }; You can check out the crateâ€™s code for more info.\nI want to write my own implementation too but Iâ€™m too lazy and it just works.\nI also decided to add this function to print out the game state. So basically what I did was:\npub fn print_board(game_state: \u0026GameStatus) { let mut board: Vec\u003cchar\u003e = Vec::new(); for piece in game_state.pieces { if piece == None { board.push(' '); } else { board.push(piece.as_ref().unwrap().symbol); } } let mut x = 8; println!(\"+---+---+---+---+---+---+---+---+\"); for rank in 0..8 { x -= 1; for file in 0..8 { let square = rank * 8 + file; if board[square] == ' ' { print!(\"| \"); } else { print!(\"| {} \", board[square]); } } print!(\"| {} \\n\", x + 1); println!(\"+---+---+---+---+---+---+---+---+\"); } println!(\" a b c d e f g h \\n\"); } Input: rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/PNBQKB1R b KQkq - 1 2\nOutput:\n+---+---+---+---+---+---+---+---+ | r | n | b | q | k | b | n | r | 8 +---+---+---+---+---+---+---+---+ | p | p | | p | p | p | p | p | 7 +---+---+---+---+---+---+---+---+ | | | | | | | | | 6 +---+---+---+---+---+---+---+---+ | | | p | | | | | | 5 +---+---+---+---+---+---+---+---+ | | | | | P | | | | 4 +---+---+---+---+---+---+---+---+ | | | | | | N | | | 3 +---+---+---+---+---+---+---+---+ | P | P | P | P | | P | P | P | 2 +---+---+---+---+---+---+---+---+ | P | N | B | Q | K | B | | R | 1 +---+---+---+---+---+---+---+---+ a b c d e f g h Anyways thatâ€™s it for this blog see you soon ðŸ‘‹.\n","wordCount":"1514","inLanguage":"en","datePublished":"2022-06-29T14:54:23+05:30","dateModified":"2022-06-29T14:54:23+05:30","mainEntityOfPage":{"@type":"WebPage","@id":"https://rv178.is-a.dev/posts/fen-string-parsing-in-rust/"},"publisher":{"@type":"Organization","name":"rv178","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/rv178/website/main/static/favicon.png"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><ul id=menu><li><a href=https://rv178.is-a.dev/ title=Home><span>Home</span></a></li><li><a href=https://rv178.is-a.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://rv178.is-a.dev/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul><div class=logo><a href=https://rv178.is-a.dev accesskey=h title="  (Alt + H)"></a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://rv178.is-a.dev>Home</a>&nbsp;Â»&nbsp;<a href=https://rv178.is-a.dev/posts/>Posts</a></div><h1 class=post-title>FEN String Parsing in Rust</h1><div class=post-meta><span title='2022-06-29 14:54:23 +0530 +0530'>June 29, 2022</span>&nbsp;Â·&nbsp;8 min&nbsp;Â·&nbsp;1514 words</div></header><div class=post-content><hr><p>I <strong>finally</strong> finished the FEN string parsing part of my chess engine after
days of procrastinating and I just wanted to share my experience with everyone.</p><p>So a FEN string looks like this:</p><pre tabindex=0><code>rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
</code></pre><p>This is the FEN string of the starting position in standard chess. It looks like random crap at first glance but
this string conveys a lot of information.</p><p>So let&rsquo;s divide it into parts.</p><h3 id=pieces>Pieces<a hidden class=anchor aria-hidden=true href=#pieces>#</a></h3><p>The first part conveys information regarding piece placement. Each letter represents a piece on each rank of the board, and numbers
denote empty spaces.</p><pre tabindex=0><code>rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR
</code></pre><p>Let&rsquo;s look at an example from chess.com here:</p><p><img loading=lazy src=https://images.chesscomfiles.com/uploads/v1/images_users/tiny_mce/pdrpnht/phpffYq5N.png alt=chess.com-example></p><p>As you can observe lower case characters are for black pieces and upper case characters are for white pieces.</p><p>Now, moving on to the second part.</p><h3 id=side-to-move>Side to move<a hidden class=anchor aria-hidden=true href=#side-to-move>#</a></h3><p>The second part consists of just a letter which can either be <code>b</code> or <code>w</code>.</p><p>Here we can observe that it&rsquo;s <code>w</code>.</p><pre tabindex=0><code>rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR | w | KQkq | - | 0 | 1
</code></pre><p>That means it&rsquo;s white&rsquo;s turn to move, and <code>b</code> means it&rsquo;s black&rsquo;s turn to move.</p><h3 id=castling-ability>Castling ability<a hidden class=anchor aria-hidden=true href=#castling-ability>#</a></h3><p>The third part contains information regarding castling ability of both sides.</p><p><code>K</code> - White can castle <strong>kingside</strong>.</p><p><code>k</code> - Black can castle <strong>kingside</strong>.</p><p><code>Q</code> - White can castle <strong>queenside</strong>.</p><p><code>q</code> - Black can castle <strong>queenside</strong>.</p><p>If no sides can castle, <code>-</code> is used like so:</p><pre tabindex=0><code>rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w - - 0 1
</code></pre><h3 id=en-passant-squares>En passant squares<a hidden class=anchor aria-hidden=true href=#en-passant-squares>#</a></h3><p>The next part gives us information if any en passant squares are possible. If there are no en passant squares, <code>-</code> is used as demonstrated in this example. If there are any, then the co-ordinates of that
square is used.</p><h3 id=half-move-clock-and-full-move-counter>Half move clock and full move counter<a hidden class=anchor aria-hidden=true href=#half-move-clock-and-full-move-counter>#</a></h3><p>The next two parts give us information regarding the number of halfmoves and fullmoves completed. Here you can observe the half move count is <code>0</code>
and the full move count is <code>1</code>.</p><h2 id=parsing-the-string>Parsing the string<a hidden class=anchor aria-hidden=true href=#parsing-the-string>#</a></h2><p>To track the current game status, I made a struct called <code>GameStatus</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>GameStatus</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> pieces: Vec<span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;</span>Piece<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> side_to_move: <span style=color:#a6e22e>Colour</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> castling_id: [<span style=color:#66d9ef>bool</span>; <span style=color:#ae81ff>4</span>],
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> en_passant: Option<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>Square<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> half_move_clock: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> full_move_count: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>What I wanted to do here was make functions for each variable and then assign it to the fields in the struct.</p><p>For parsing the side to move I first created an enumerator called <code>Colour</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Colour</span> {
</span></span><span style=display:flex><span>    White,
</span></span><span style=display:flex><span>    Black,
</span></span><span style=display:flex><span>    Undefined,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>White and Black are both sides, and undefined is used for error handling if the input is invalid.</p><p>I then created a function that will return a value based on the input given. I really love rust&rsquo;s match syntax ðŸ˜„.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>active_side</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#a6e22e>Colour</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> input {
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;w&#34;</span> <span style=color:#f92672>=&gt;</span> Colour::White,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;b&#34;</span> <span style=color:#f92672>=&gt;</span> Colour::Black,
</span></span><span style=display:flex><span>        _ <span style=color:#f92672>=&gt;</span> Colour::Undefined,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>if</span> colour <span style=color:#f92672>==</span> Colour::Undefined {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;Invalid FEN string: Failed to parse active colour.&#34;</span>);
</span></span><span style=display:flex><span>    exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For parsing castling ability I decided to make an array of bools that would contain values corresponding to the info parsed from
the string.</p><blockquote><p><code>[true, true, true, true]</code> if input is <code>KQkq</code> (all sides can castle both ways).</p></blockquote><p>Index <code>0</code> checks if the white king can castle kingside. ie, <code>K</code> and so on.</p><p>Index <code>1</code> => can white king castle queenside?</p><p>Index <code>2</code> => can black king castle kingside?</p><p>Index <code>3</code> => can black king castle queenside?</p><p>So I made a function that returns this array of bools.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>castling_ability</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; [<span style=color:#66d9ef>bool</span>; <span style=color:#ae81ff>4</span>] {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> input <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;-&#34;</span> {
</span></span><span style=display:flex><span>        [<span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>]
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> castling_id <span style=color:#f92672>=</span> [<span style=color:#66d9ef>false</span>; <span style=color:#ae81ff>4</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> castling_id_str <span style=color:#f92672>=</span> input.to_string();
</span></span><span style=display:flex><span>        castling_id_str.retain(<span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> c <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;-&#39;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> c <span style=color:#66d9ef>in</span> castling_id_str.chars() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> c {
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;K&#39;</span> <span style=color:#f92672>=&gt;</span> castling_id[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;Q&#39;</span> <span style=color:#f92672>=&gt;</span> castling_id[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;k&#39;</span> <span style=color:#f92672>=&gt;</span> castling_id[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;q&#39;</span> <span style=color:#f92672>=&gt;</span> castling_id[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>                _ <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    println!(<span style=color:#e6db74>&#34;Invalid FEN string: Failed to parse castling ability.&#34;</span>);
</span></span><span style=display:flex><span>                    exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        castling_id
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For parsing en passant squares the solution I came up with was rather stupid.</p><p>Since the input can either be <code>-</code> or multiple squares like <code>e4e5g6</code> etc., I wanted a vector that contained each square.</p><p>So basically,</p><blockquote><p><code>e4e5g6</code> => <code>[Square::E4, Square::E5, Square::G6]</code></p></blockquote><p>(Square is an enum, this change was made later. Check <a href=https://rv178.is-a.dev/posts/bitboards-in-rust/>this blog</a> for more info. Yes, I updated this blog :D)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>en_passant</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; Option<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>Square<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> input.chars().all(<span style=color:#66d9ef>char</span>::is_whitespace) <span style=color:#f92672>|</span> input.contains(<span style=color:#e6db74>&#39;-&#39;</span>) {
</span></span><span style=display:flex><span>        None
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> chars <span style=color:#f92672>=</span> input.chars().collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> chars.len() <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> ep_vec <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> sq;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>chars.len() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> i <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> valid_chars <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;a&#39;</span>, <span style=color:#e6db74>&#39;b&#39;</span>, <span style=color:#e6db74>&#39;c&#39;</span>, <span style=color:#e6db74>&#39;d&#39;</span>, <span style=color:#e6db74>&#39;e&#39;</span>, <span style=color:#e6db74>&#39;f&#39;</span>, <span style=color:#e6db74>&#39;g&#39;</span>, <span style=color:#e6db74>&#39;h&#39;</span>];
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> invalid <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> c <span style=color:#66d9ef>in</span> valid_chars.iter() {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> chars[i] <span style=color:#f92672>==</span> <span style=color:#f92672>*</span>c {
</span></span><span style=display:flex><span>                            invalid <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&lt;</span> chars.len() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>chars[i].is_alphabetic() <span style=color:#f92672>|</span> <span style=color:#f92672>!</span>chars[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>].is_numeric() {
</span></span><span style=display:flex><span>                            fen_log!(<span style=color:#e6db74>&#34;Invalid FEN string: Failed to parse en passant square.&#34;</span>);
</span></span><span style=display:flex><span>                            exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> chars[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>                            .to_digit(<span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>                            .expect(<span style=color:#e6db74>&#34;Could not parse character to digit (en passant)&#34;</span>)
</span></span><span style=display:flex><span>                            <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>                        {
</span></span><span style=display:flex><span>                            invalid <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> invalid {
</span></span><span style=display:flex><span>                        fen_log!(<span style=color:#e6db74>&#34;Invalid FEN string: Failed to parse en passant square.&#34;</span>);
</span></span><span style=display:flex><span>                        exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> file;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>match</span> chars[i] {
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#f92672>=&gt;</span> file <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;b&#39;</span> <span style=color:#f92672>=&gt;</span> file <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;c&#39;</span> <span style=color:#f92672>=&gt;</span> file <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;d&#39;</span> <span style=color:#f92672>=&gt;</span> file <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;e&#39;</span> <span style=color:#f92672>=&gt;</span> file <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>,
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;f&#39;</span> <span style=color:#f92672>=&gt;</span> file <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>,
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;g&#39;</span> <span style=color:#f92672>=&gt;</span> file <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>,
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;h&#39;</span> <span style=color:#f92672>=&gt;</span> file <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>,
</span></span><span style=display:flex><span>                        _ <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                            fen_log!(<span style=color:#e6db74>&#34;Invalid FEN string: Failed to parse en passant square.&#34;</span>);
</span></span><span style=display:flex><span>                            exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> rank;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>match</span> chars[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] {
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;1&#39;</span> <span style=color:#f92672>=&gt;</span> rank <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>,
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;2&#39;</span> <span style=color:#f92672>=&gt;</span> rank <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>,
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;3&#39;</span> <span style=color:#f92672>=&gt;</span> rank <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>,
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;4&#39;</span> <span style=color:#f92672>=&gt;</span> rank <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>,
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;5&#39;</span> <span style=color:#f92672>=&gt;</span> rank <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;6&#39;</span> <span style=color:#f92672>=&gt;</span> rank <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;7&#39;</span> <span style=color:#f92672>=&gt;</span> rank <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#39;8&#39;</span> <span style=color:#f92672>=&gt;</span> rank <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>                        _ <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                            fen_log!(<span style=color:#e6db74>&#34;Invalid FEN string: Failed to parse en passant square.&#34;</span>);
</span></span><span style=display:flex><span>                            exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    sq <span style=color:#f92672>=</span> rank <span style=color:#f92672>*</span> <span style=color:#ae81ff>8</span> <span style=color:#f92672>+</span> file;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    ep_vec.push(match_u32_to_sq(sq <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Some(ep_vec)
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            fen_log!(<span style=color:#e6db74>&#34;Invalid FEN string: Failed to parse en passant square.&#34;</span>);
</span></span><span style=display:flex><span>            exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Parsing the halfmove and fullmove counts were rather easy, and I just had to return a u32 from the string input.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>halfmove_clock</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#66d9ef>u32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> halfmove_clock <span style=color:#f92672>=</span> String::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> c <span style=color:#66d9ef>in</span> input.chars() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> c.is_digit(<span style=color:#ae81ff>10</span>) {
</span></span><span style=display:flex><span>            halfmove_clock.push(c);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    halfmove_clock.parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;</span>().unwrap()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fullmove_count</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#66d9ef>u32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> fullmove_clock <span style=color:#f92672>=</span> String::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> c <span style=color:#66d9ef>in</span> input.chars() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> c.is_digit(<span style=color:#ae81ff>10</span>) {
</span></span><span style=display:flex><span>            fullmove_clock.push(c);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    fullmove_clock.parse::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;</span>().unwrap()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>However for piece placement parsing, I saw a really good implementation of it in the <a href=https://lib.rs/crates/fen>fen</a> crate so I decided to just
joink it ðŸ˜”.</p><p>There&rsquo;s a struct called <code>Piece</code> that stores the type, colour and symbol (added by me to print out pieces in the board).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Piece</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> kind: <span style=color:#a6e22e>Kind</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> colour: <span style=color:#a6e22e>Colour</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> symbol: <span style=color:#66d9ef>char</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And an enum <code>Kind</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Kind</span> {
</span></span><span style=display:flex><span>    King,
</span></span><span style=display:flex><span>    Queen,
</span></span><span style=display:flex><span>    Bishop,
</span></span><span style=display:flex><span>    Knight,
</span></span><span style=display:flex><span>    Rook,
</span></span><span style=display:flex><span>    Pawn,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And according to the input given, a value is returned that is later pushed to a vector.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> (color, kind, symbol) <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> piece_char {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;P&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::White, Kind::Pawn, <span style=color:#e6db74>&#39;P&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;N&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::White, Kind::Knight, <span style=color:#e6db74>&#39;N&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;B&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::White, Kind::Bishop, <span style=color:#e6db74>&#39;B&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;R&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::White, Kind::Rook, <span style=color:#e6db74>&#39;R&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;Q&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::White, Kind::Queen, <span style=color:#e6db74>&#39;Q&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;K&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::White, Kind::King, <span style=color:#e6db74>&#39;K&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;p&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::Black, Kind::Pawn, <span style=color:#e6db74>&#39;p&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;n&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::Black, Kind::Knight, <span style=color:#e6db74>&#39;n&#39;</span>),
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;b&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::Black, Kind::Bishop, <span style=color:#e6db74>&#39;b&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;r&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::Black, Kind::Rook, <span style=color:#e6db74>&#39;r&#39;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;q&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::Black, Kind::Queen, <span style=color:#e6db74>&#39;q&#39;</span>),
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;k&#39;</span> <span style=color:#f92672>=&gt;</span> (Colour::Black, Kind::King, <span style=color:#e6db74>&#39;k&#39;</span>),
</span></span><span style=display:flex><span>    _ <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>return</span> None,
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>You can check out the crate&rsquo;s code for more info.</p><p>I want to write my own implementation too but I&rsquo;m too lazy and it just works.</p><p>I also decided to add this function to print out the game state. So basically what I did was:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print_board</span>(game_state: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>GameStatus</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> board: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> piece <span style=color:#66d9ef>in</span> game_state.pieces {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> piece <span style=color:#f92672>==</span> None {
</span></span><span style=display:flex><span>            board.push(<span style=color:#e6db74>&#39; &#39;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            board.push(piece.as_ref().unwrap().symbol);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;+---+---+---+---+---+---+---+---+&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> rank <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>8</span> {
</span></span><span style=display:flex><span>        x <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> file <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>8</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> square <span style=color:#f92672>=</span> rank <span style=color:#f92672>*</span> <span style=color:#ae81ff>8</span> <span style=color:#f92672>+</span> file;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> board[square] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39; &#39;</span> {
</span></span><span style=display:flex><span>                print!(<span style=color:#e6db74>&#34;|   &#34;</span>);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                print!(<span style=color:#e6db74>&#34;| </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> &#34;</span>, board[square]);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        print!(<span style=color:#e6db74>&#34;| </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;+---+---+---+---+---+---+---+---+&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;  a   b   c   d   e   f   g   h  </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Input: <code>rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/PNBQKB1R b KQkq - 1 2</code></p><p>Output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-md data-lang=md><span style=display:flex><span>+---+---+---+---+---+---+---+---+
</span></span><span style=display:flex><span>| r | n | b | q | k | b | n | r | 8
</span></span><span style=display:flex><span>+---+---+---+---+---+---+---+---+
</span></span><span style=display:flex><span>| p | p |   | p | p | p | p | p | 7
</span></span><span style=display:flex><span>+---+---+---+---+---+---+---+---+
</span></span><span style=display:flex><span>|   |   |   |   |   |   |   |   | 6
</span></span><span style=display:flex><span>+---+---+---+---+---+---+---+---+
</span></span><span style=display:flex><span>|   |   | p |   |   |   |   |   | 5
</span></span><span style=display:flex><span>+---+---+---+---+---+---+---+---+
</span></span><span style=display:flex><span>|   |   |   |   | P |   |   |   | 4
</span></span><span style=display:flex><span>+---+---+---+---+---+---+---+---+
</span></span><span style=display:flex><span>|   |   |   |   |   | N |   |   | 3
</span></span><span style=display:flex><span>+---+---+---+---+---+---+---+---+
</span></span><span style=display:flex><span>| P | P | P | P |   | P | P | P | 2
</span></span><span style=display:flex><span>+---+---+---+---+---+---+---+---+
</span></span><span style=display:flex><span>| P | N | B | Q | K | B |   | R | 1
</span></span><span style=display:flex><span>+---+---+---+---+---+---+---+---+
</span></span><span style=display:flex><span>  a   b   c   d   e   f   g   h
</span></span></code></pre></div><p>Anyways that&rsquo;s it for this blog see you soon ðŸ‘‹.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://rv178.is-a.dev/tags/fen/>fen</a></li><li><a href=https://rv178.is-a.dev/tags/chess/>chess</a></li><li><a href=https://rv178.is-a.dev/tags/rust/>rust</a></li></ul><nav class=paginav><a class=prev href=https://rv178.is-a.dev/posts/writing-a-build-automation-tool/><span class=title>Â« Prev</span><br><span>Writing a Build Automation Tool</span></a>
<a class=next href=https://rv178.is-a.dev/posts/my-linux-journey/><span class=title>Next Â»</span><br><span>A brief recap of my Linux journey up until now</span></a></nav></footer></article></main><footer class=footer><span>Copyright &copy; 2025 <a href=https://rv178.is-a.dev>rv178</a></span>
<span>| <a href=https://github.com/rv178/website rel=noopener target=_blank>Source code</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>