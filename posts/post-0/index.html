<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Binary Exponentiation Extended | rv178</title><meta name=keywords content><meta name=description content="I could not find any article or blog on this idea, and felt having one could be helpful to many. There might be unwanted errors, so please feel free to to share any suggestions, corrections or concerns. For those who are unware of Binary Exponentation, this CP-Algorithms article or this video by Errichto can help get familiar with it.
Introduction Now that we know the idea behind binary exponentiation; let us try expanding the idea."><meta name=author content><link rel=canonical href=https://rv178.is-a.dev/posts/post-0/><link crossorigin=anonymous href=/assets/css/stylesheet.29a7535ae3148c25cfd9661c085d5568afc290dd9abd041803f5964043035889.css integrity="sha256-KadTWuMUjCXP2WYcCF1VaK/CkN2avQQYA/WWQEMDWIk=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://rv178.is-a.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rv178.is-a.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rv178.is-a.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://rv178.is-a.dev/apple-touch-icon.png><link rel=mask-icon href=https://rv178.is-a.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script>
<script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"]]}}</script><meta property="og:title" content="Binary Exponentiation Extended"><meta property="og:description" content="I could not find any article or blog on this idea, and felt having one could be helpful to many. There might be unwanted errors, so please feel free to to share any suggestions, corrections or concerns. For those who are unware of Binary Exponentation, this CP-Algorithms article or this video by Errichto can help get familiar with it.
Introduction Now that we know the idea behind binary exponentiation; let us try expanding the idea."><meta property="og:type" content="article"><meta property="og:url" content="https://rv178.is-a.dev/posts/post-0/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-29T14:54:23+05:30"><meta property="article:modified_time" content="2022-06-29T14:54:23+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Binary Exponentiation Extended"><meta name=twitter:description content="I could not find any article or blog on this idea, and felt having one could be helpful to many. There might be unwanted errors, so please feel free to to share any suggestions, corrections or concerns. For those who are unware of Binary Exponentation, this CP-Algorithms article or this video by Errichto can help get familiar with it.
Introduction Now that we know the idea behind binary exponentiation; let us try expanding the idea."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://rv178.is-a.dev/posts/"},{"@type":"ListItem","position":3,"name":"Binary Exponentiation Extended","item":"https://rv178.is-a.dev/posts/post-0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Binary Exponentiation Extended","name":"Binary Exponentiation Extended","description":"I could not find any article or blog on this idea, and felt having one could be helpful to many. There might be unwanted errors, so please feel free to to share any suggestions, corrections or concerns. For those who are unware of Binary Exponentation, this CP-Algorithms article or this video by Errichto can help get familiar with it.\nIntroduction Now that we know the idea behind binary exponentiation; let us try expanding the idea.","keywords":[],"articleBody":"I could not find any article or blog on this idea, and felt having one could be helpful to many. There might be unwanted errors, so please feel free to to share any suggestions, corrections or concerns. For those who are unware of Binary Exponentation, this CP-Algorithms article or this video by Errichto can help get familiar with it.\nIntroduction Now that we know the idea behind binary exponentiation; let us try expanding the idea. Say, we break the problem into two parts, $L$ and $R$, such that, once we have both the results, combining them gives us our final answer as $ans = L \\odot R$, where $\\odot$ is an associative binary operator. If we can find $R$ as a function of $L$ as in $R = f(L)$ fast enough, say $O(X)$, then our final answer can be found in $O(X \\cdot log(n))$.\nThe idea is simple enough, so we now have a look at some simple examples. For the sake of simplicity we assume problem size $n$ is of form $2^k$ , $ k \\in \\mathbb{Z} $ .\nExample 1: Calculating $a^n$ We are starting from the simplest example. We know that $ans = \\underbrace{a \\cdot a \\dots \\cdot a \\cdot a }_\\text{ n times}$. If we take $R = f(L) = L$, where $L = a^{n/2}$; we can find $R$ in $O(1)$ and build our answer as -\n$\\newline$\n$$ans = \\underbrace{\\underbrace{\\dots \\dots \\dots}{L} \\odot \\underbrace{\\dots \\dots \\dots}{R=f(L)}}{L’} \\odot \\underbrace{\\dots \\dots \\dots \\dots \\dots \\dots \\dots}{R` = f(L’)} ; \\odot \\dots \\dots$$\nWe are able to compute $R’$ directly from $L’$, unlike other methods such as RMQ or Binary Lifting where we build our answer from already calculated $L$ and $R$ on the independent smaller ranges to later combine them to compute the the answer for the bigger range.\nTime Complexity: Finding $R = f(L)$ is $O(1)$, so total time complexity is $O(log(n))$. Implementation The below function only works if $n$ is even. One simple way to handle the odd case is to break the expression as $a^n = a \\cdot a^{n-1}$. We can get the answer for $a^{n-1}$ because it’s even ans whether $n$ is even or odd, in $\\leq 2$ steps $n$ definitely gets halved which ensures that the time complexity remains $O(log(n))$.\nint binexpo(int a,int n) { if (n == 1) return a; if (n % 2) return a * binexpo(a, n - 1); // this line happen only #SetBits times as on every step n is halving int L = binexpo(a, n / 2); int R = L; return R * L; } Example 2: Summation of GP Series Considering a standard GP series, we find its summation as\n$\\newline$\n$$ans = 1 + r + r^{2} \\dots r^{n-1} = \\frac{r^{n}-1}{r-1}$$\nIf we have to find the summation under arbitrary MOD then it’s not necessary that $(r-1)^{-1}$ exists, and so we alternatively express our sum as\n$$ans = \\underbrace{1 + r + r^{2} \\dots r^{ \\frac{n-1}{2} } }\\text{L} + \\underbrace{r^{ \\frac{n}{2} } + \\dots + r^{n-1}}\\text{R} $$\nwhich gives $R = f(L) = r^{\\frac{n}{2}} \\cdot L$.\nTo handle the case for odd $n$ during implementation, we can break series as\n$\\newline$\n$$ans = 1 + a \\cdot \\underbrace{(1 + a + a^2 + \\dots + a^{n-2})}_\\text{say sum is S}$$\nWe can find $S$ as $(n - 1)$ is even, and final answer will be $= 1 + a \\cdot S$.\nTime Complexity: Computing $R = f(L)$ is $O(log(n))$, so our total time complexity becomes $O(log(n)^{2})$. But we can calculate powers of $r$ along with our series, so we restrict the final time complexity to $O(log(n))$.\nImplementation Naive Approach ($O(log(n)^{2})$)\nint binexpo(int x,int n){/* above code goes here */} int GP(int r, int n) { if (n == 1) return 1; if (n % 2) return 1 + r * GP(r, n - 1); int L = GP(r, n / 2); int R = binexpo(r, n / 2) * L; return L + R; } Now, applying our optimization, we compute { $ { r^n ,1 + r \\dots + r^{n-1} } $ } together for a final time complexity of $O(logn)$\n// {r^n, 1 + r + r^2 ... r^(n-1)} pair\u003cint, int\u003e GP(int r, int n) { if (n == 1) return {r, 1}; if (n \u0026 1) { auto [x, y] = GP(r, n - 1); return {r * x, 1 + r * y}; } auto [x, L] = GP(r, n / 2); int R = x * L; return {x * x, R + L}; } We can use a similar idea for calculating GP series of matrices $= I + A + A^2 + \\dots + A^{n-1}$. Just like integers under modulo, we can’t always guarantee $(A-I)^{-1}$ exists.\nContest Example: In AtCoder ABC 293 Task E the task is to just compute the sum of a GP series.\nExample 3: Summation of AP-GP series We start by considering the simple series $\\displaystyle r + 2 \\cdot r^2 + 3 \\cdot r^3 \\dots + (n-1)\\cdot r^{n-1} = \\sum\\limits_{i=0}^{n-1} i\\cdot r^i$. For this we express the summation as below\n$$ans = \\underbrace{r + 2 \\cdot r^2 + \\dots + (\\frac{n}{2}-1) \\cdot r^{ \\frac{n}{2}-1 }}\\text{L} + \\underbrace{ \\frac{n}{2} \\cdot r^{\\frac{n}{2}} + \\dots + (n-1) \\cdot r^{n-1}}\\text{R} $$\nNow we solve for $R = f(L)$.\nSolution for R as a function of L $$R = (\\frac{n}{2} + 0) \\cdot r^{\\frac{n}{2}} + (\\frac{n}{2} + 1) \\cdot r^{\\frac{n}{2}+1} + \\dots + (\\frac{n}{2} + i) \\cdot r^{\\frac{n}{2}+i} + \\dots + (\\frac{n}{2} + \\frac{n}{2}-1) \\cdot r^{\\frac{n}{2} + \\frac{n}{2}-1}$$\n$$\\implies R = \\frac{n}{2} \\cdot \\left( r^{\\frac{n}{2}} + r^{\\frac{n}{2}+1} + \\dots + r^{\\frac{n}{2}+i} + \\dots + r^{n-1} \\right) + r^{\\frac{n}{2}} \\cdot \\underbrace{\\left( 0 \\cdot r^{0} + 1 \\cdot r^{1} + \\dots + i \\cdot r^{i} + \\dots + \\left(\\frac{n}{2}-1\\right) \\cdot r^{\\frac{n}{2}-1} \\right)}_{\\text{L}}$$\n$$\\implies R = r^{\\frac{n}{2}} \\cdot \\left( \\frac{n}{2} \\cdot \\underbrace{\\left( 1 + r^{1} + \\dots + r^{i} + \\dots + r^{\\frac{n}{2}-1} \\right)}_{\\text{GP series}} + L \\right)$$\nWe shall call this GP series as $L_{0}$, whose sum we can already calculate efficiently. Hence,\n$$R = r^{\\frac{n}{2}} \\cdot \\left( \\frac{n}{2} \\cdot L_{0} + L \\right)$$\n$$\\implies R = f(L_{0},L) = r^{\\frac{n}{2}} \\cdot \\left( \\frac{n}{2} \\cdot L_{0} + L \\right)$$\nTo handle the odd case during implementation, we express summation as:\n$\\newline$\n$$sum = r + 2\\cdot r^2 + \\dots + (n-1) \\cdot r^{n-1}$$ $$= \\left(r + r^2 + \\dots + r^i + \\dots + r^{n-1} \\right) + \\left( r^2 + 2\\cdot r^3 + \\dots + (i-1)\\cdot r^{i-1} + \\dots + (n-2)\\cdot r^{n-1} \\right)$$\n$$= r \\cdot \\underbrace{\\left(1 + r^1 + \\dots + r^i + \\dots + r^{n-2} \\right)}\\text{X} + r \\cdot \\underbrace{\\left( r^1 + 2\\cdot r^2 + \\dots + i\\cdot r^{i} + \\dots + (n-2)\\cdot r^{n-2} \\right)}\\text{Y}$$\nWe can get $X$ and $Y$ because they are of even length, and our final answer will be $= r \\cdot X + r \\cdot Y$ .\nTime Complexity: To get $R$ we need to solve $L_{0}$ which takes $O(log(n))$ so total will be $O(log(n)^2)$, but we can calculate powers of $r$, $L_{0}$ and $L$ together which makes total time $O(log(n))$.\nImplementation // {r^n , 1+r+r^2 ... + r^(n-1) , 0 + r + 2r^2 + ... + (n-1)r^(n-1) } array\u003cint, 3\u003e APGP(int r, int n) { if (n == 1) return {r, 1, 0}; if (n \u0026 1) { auto [x, L0, L] = APGP(r, n - 1); return {r * x, 1 + r * L0, r * L0 + r * L}; } auto [x, L0, L] = APGP(r, n / 2); int R0 = x * L0; int R = x * (n / 2 * L0 + L); return {x * x, L0 + R0, L + R}; } For any generic AP-GP series $\\sum_{i=0}^{n-1} ( a + i \\cdot b ) \\cdot r^i = a \\cdot \\underbrace{\\sum_{i=0}^{n-1} r^i}{\\text{L0}} + b \\cdot \\underbrace{\\sum{i=0}^{n-1} i \\cdot r^i}{\\text{L}} = a \\cdot L{0} + b \\cdot L$, where both are being calculated with single function call.\nAtCoder ABC 129 task F is a good practice example for the ideas in the blog.\nGenralising the above series summations Now, let us consider $\\displaystyle S(n,m) = ‎‎\\sum\\limits_{i=0}^{n-1} i^m \\cdot r^i $. Then we would have GP $= S(n,0)$ and AP-GP $= S(n,1)$. Hence,\n$\\newline$\n$$\\displaystyle S(n,m) = r + 2^m \\cdot r^2 + \\dots + i^m \\cdot r^i + \\dots + (n-1)^m \\cdot r^{n-1}$$\n$$\\displaystyle = \\underbrace{r + 2^m \\cdot r^2 + \\dots + (\\frac{n}{2}-1)^{m} \\cdot r^{\\frac{n}{2}-1}}\\text{L(m,n/2)} + \\underbrace{{(\\frac{n}{2}})^{m} \\cdot r^{\\frac{n}{2}} + \\dots + (n-1)^m \\cdot r^{n-1}}\\text{R(m,n/2)}$$\nHere $L_{m,\\frac{n}{2}} = S(\\frac{n}{2},m)$. Then, $S(n,m) = L_{m,\\frac{n}{2}} + R_{m,\\frac{n}{2}}$, We need to compute $R_{m,\\frac{n}{2}}$.\n$\\newline$\n$$\\displaystyle R_{m,\\frac{n}{2}} = r^{\\frac{n}{2}} \\cdot \\left( (\\frac{n}{2})^m + (\\frac{n}{2}+1)^m \\cdot r + \\dots + (\\frac{n}{2} + i)^m \\cdot r^i + \\dots (\\frac{n}{2} + \\frac{n}{2} - 1)^m \\cdot r^{\\frac{n}{2}-1} \\right)$$\n$$\\displaystyle R_{m,\\frac{n}{2}} = r^{\\frac{n}{2}} \\cdot \\left( \\sum\\limits_{i=0}^{\\frac{n}{2}-1} \\left( \\sum\\limits_{j=0}^{m} \\binom{m}{j} \\left(\\frac{n}{2}\\right)^{m-j} \\cdot i^j \\right) \\cdot r^i \\right) $$\nNow, swapping the summations -\n$$\\displaystyle R_{m,\\frac{n}{2}} = r^{\\frac{n}{2}} \\cdot \\left( \\sum\\limits_{j=0}^{m} \\binom{m}{j} \\left( \\frac{n}{2}\\right) ^{m-j} \\underbrace{\\left( \\sum\\limits_{i=0}^{\\frac{n}{2}-1} i^j \\cdot r^i \\right)}_\\text{L(j,n/2)} \\right) $$\nFinally,\n$$\\displaystyle R_{m,\\frac{n}{2}} = r^{\\frac{n}{2}} \\cdot \\left( \\sum\\limits_{j=0}^{m} \\binom{m}{j} \\left( \\frac{n}{2}\\right) ^{m-j} \\cdot L_{j,\\frac{n}{2}} \\right) = r^{\\frac{n}{2}} \\cdot \\left( \\sum\\limits_{j=0}^{m} \\binom{m}{j} \\left( \\frac{n}{2}\\right) ^{m-j} \\cdot S_{\\frac{n}{2},j} \\right) $$\nAs $j \\leq m$ if we calculate everything together, just like above and hence know the value of every $L_{j,\\frac{n}{2}}$ without any extra time. We can validate our results for the above illustrated examples of AP and AP-GP series.\nValidating our results against our previous examples Case 1: for $m=0$ , which is simple GP series\n$R_{0,\\frac{n}{2}} = r^{\\frac{n}{2}} \\cdot \\left( \\sum\\limits_{j=0}^{0} \\binom{0}{j} \\left( \\frac{n}{2}\\right) ^{0-j} \\cdot L_{j,\\frac{n}{2}} \\right) = r^{\\frac{n}{2}} \\cdot L_{0,\\frac{n}{2}}$\nCase 2: for $m=1$ , which is AP-GP series\n$R_{1,\\frac{n}{2}} = r^{\\frac{n}{2}} \\cdot \\left( \\sum\\limits_{j=0}^{1} \\binom{1}{j} \\left( \\frac{n}{2}\\right) ^{1-j} \\cdot L_{j,\\frac{n}{2}} \\right) = r^{\\frac{n}{2}} \\cdot \\left( \\left( \\frac{n}{2}\\right) ^{1} \\cdot L_{0,\\frac{n}{2}} + L_{1,\\frac{n}{2}} \\right)$\nWe can now evaluate our original summation as $\\displaystyle S_{n,m} = S_{\\frac{n}{2},m} + r^{\\frac{n}{2}} \\cdot \\left( \\sum\\limits_{j=0}^{m} \\binom{m}{j} \\left( \\frac{n}{2}\\right) ^{m-j} \\cdot S_{\\frac{n}{2},j} \\right)$.\nHandling Odd Case We have $\\displaystyle S_{n,m} = \\sum\\limits_{i=0}^{n-1} i^m \\cdot r^i = r \\cdot \\left( \\sum\\limits_{i=1}^{n-2} (i+1)^m \\cdot r^i \\right)$. However we can only write this if $m\u003e0$ but for $m=0$ first term will not be $0$ but instead be $\\displaystyle \\lim_{x \\to 0} x^x = 1$. So for $m=0$ we will add $1$ instead of $0$, keeping the remainder of the expression same. Thus\n$$\\displaystyle S_{n,m} = r \\cdot \\left( \\sum\\limits_{i=0}^{n-2} \\sum\\limits_{j=0}^{m} \\binom{m}{j} i^j \\cdot r^i \\right)$$\nAnd swapping summations\n$$\\displaystyle S_{n,m} = r \\cdot \\left( \\sum\\limits_{j=0}^{m} \\binom{m}{j} \\underbrace{\\sum\\limits_{i=0}^{n-2} i^j \\cdot r^i}\\text{S(n-1,j)} \\right) = r \\cdot \\left( \\sum\\limits{j=0}^{m} \\binom{m}{j} S_{n-1,j} \\right) \\hspace{0.25cm} \\text{for} \\hspace{0.25cm}m \u003e 0$$\nHence, we have the final result as:\n$$ \\displaystyle \\begin{equation} S_{n,m}= \\begin{cases} 1 + r \\cdot S_{n-1,0} \u0026 \\text{if } m=0\\ r \\cdot \\left(\\displaystyle \\sum\\limits_{j=0}^{m} \\binom{m}{j} S_{n-1,j} \\right) \u0026 \\text{if } m \u003e 0 \\end{cases} \\end{equation} $$\nWe can also construct a clean visualization of the even and odd cases using matrix multiplication instead of summation. These are illustrated as below.\nOdd Case Dimensions are: $(m+1,1) = (m+1,m+2) \\cdot (m+2,1)$.\n$$\\begin{bmatrix} S_{n,0} \\ S_{n,1} \\ \\vdots \\ S_{n,m} \\end{bmatrix} = \\begin{bmatrix} 1 \u0026 \\binom{0}{0} \u0026 0 \u0026 0 \u0026 \\dots \u0026 0 \\ 0 \u0026 \\binom{1}{0} \u0026 \\binom{1}{1} \u0026 0 \u0026 \\dots \u0026 0 \\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \u0026 \\vdots \\ 0 \u0026 \\binom{m}{0} \u0026 \\binom{m}{1} \u0026 \\binom{m}{2} \u0026 \\dots \u0026 \\binom{m}{m} \\end{bmatrix} \\cdot \\begin{bmatrix} 1 \\ r \\cdot S_{n-1,0} \\ r \\cdot S_{n-1,1} \\ \\vdots \\ r \\cdot S_{n-1,m} \\end{bmatrix}$$\nWe will return the array $(S_{n,0},S_{n,1}, \\dots , S_{n,m}, r^n)$.\nEven Case Dimension are: $(m+1,1) = (m+1,m+1) \\cdot (m+1,1)$.\n$$ \\begin{bmatrix} R_{0,\\frac{n}{2}} \\ R_{1,\\frac{n}{2}} \\ \\vdots \\ R_{m,\\frac{n}{2}}\n\\end{bmatrix} = r^{\\frac{n}{2}} \\cdot \\begin{bmatrix} \\binom{0}{0} \u0026 0 \u0026 0 \u0026 \\dots \u0026 0 \\ \\binom{1}{0} \\cdot \\frac{n}{2} \u0026 \\binom{1}{1} \u0026 0 \u0026 \\dots \u0026 0 \\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\ \\binom{m}{0} \\cdot \\left(\\frac{n}{2}\\right)^m \u0026 \\binom{m}{1} \\cdot \\left(\\frac{n}{2}\\right)^{m-1} \u0026 \\binom{m}{2} \\cdot \\left(\\frac{n}{2}\\right)^{m-2} \u0026 \\dots \u0026 \\binom{m}{m}\n\\end{bmatrix} \\cdot \\begin{bmatrix} L_{0,\\frac{n}{2}} \\ L_{1,\\frac{n}{2}} \\ L_{2,\\frac{n}{2}} \\ \\vdots \\ L_{m,\\frac{n}{2}}\n\\end{bmatrix} $$\nWe will return the array $(L_{0, n/2} + R_{0, n/2},L_{1, n/2} + R_{1, n/2}, \\dots , L_{m, n/2} + R_{m, n/2}, r^n)$.\nIn the above cases, whenever we are computing values of $R_{j, n / 2} \\hspace{0.25cm} \\text{for} \\hspace{0.25cm} j \\in [0, m]$, they still indeed maintain our original form of $R = f(L)$ as we can express them as\n$$\\vec{R_{\\frac{n}{2}}} = f(\\vec{L})= r^{\\frac{n}{2}} \\left( M(n,m) \\cdot \\vec{L_{\\frac{n}{2}}} \\right) $$\nTime Complexity: To find $R_{j,\\frac{n}{2}}$ takes summation of $m$ terms and we do that for every $j \\leq m$ which will take $O(m^2)$. So, total complexity is $O(m^2 \\cdot log(n)).$\nImplementation Precalculation of $nCr$ takes $O(m^2)$.\nDuring our computations, whenever we have even $n$ we need to compute $(\\frac{n}{2})^j$ for each $j \\leq m$, which takes $O(m \\cdot log(n))$.\nTotal complexity $O(m^2 + m \\cdot log(n) + m^2 \\cdot log(n))$ asymptotically remains same $O(m^2 \\cdot log(n))$ .\nusing int64 = long long; int MOD = 1e9+7; const int M=1002; void add(int\u0026x,int y){ x+=y; if(x\u003e=MOD)x-=MOD; } void mul(int\u0026x,int y){ x = 1ll * x * y % MOD; } int ncr[M][M]{0}; int nCr(int nn,int rr){ return ncr[nn][rr]; } // Precalculate calculate n choose r in O(M^2) void nCrinit(){ ncr[0][0]=1; for(int n=0;n\u003cM;n++)ncr[n][n]=1,ncr[n][0]=1; for(int n=1;n\u003cM;n++){ for(int r=1;r\u003cn;r++){ add(ncr[n][r],ncr[n-1][r-1]); add(ncr[n][r],ncr[n-1][r]); } } } // Precalculation of powers of n in O(M * logN) using vt = vector\u003cint\u003e; map\u003cint64,vt\u003e ni; int n_i(int64 n,int i){ return ni[n][i]; } void n_iinit(int64 n){ while(n\u003e0){ if(n\u00261){ n--; continue; } vt x(M); x[0]=1; for(int i=1;i\u003cM;i++)x[i] = 1ll * x[i-1] * (n/2 % MOD) % MOD; ni[n/2] = x; n\u003e\u003e=1; } ni[1] = vector\u003cint\u003e(M,1); } // Function to generate the series {S(n,0),S(n,1),...,S(n,m),r^n} vector\u003cint\u003e Series(int r,int64 n,int m) { if(n==1){ vector\u003cint\u003e a(m+2,0); a[0]=1; a[m+1]=r; return a; } if(n\u00261){ // Recursive case for odd n vector\u003cint\u003ea = Series(r,n-1,m); vector\u003cint\u003e S(m+2,0); add(S[m+1],1ll * r * a[m+1]%MOD); add(S[0],1); add(S[0],1ll*r*a[0]%MOD); for(int i=1;i\u003c=m;i++){ for(int j=0;j\u003c=i;j++){ add(S[i], 1ll * nCr(i,j) * a[j] % MOD); } mul(S[i],r); } return S; } // Recursive case for even n vector\u003cint\u003e L = Series(r,n/2,m); vector\u003cint\u003e R(m+1,0); for(int i=0;i\u003c=m;i++){ for(int j=0;j\u003c=i;j++){ int h = 1; mul(h,nCr(i,j)); mul(h,n_i(n/2,i-j)); mul(h,L[m+1]); mul(h,L[j]); add(R[i],h); } } vector\u003cint\u003e S(m+2,0); S[m+1] = 1ll * L[m+1] * L[m+1] % MOD; for(int i=0;i\u003c=m;i++){ // S[i]=(MOD + R[i] + L[i])%MOD; add(S[i],R[i]); add(S[i],L[i]); } return S; } ","wordCount":"2383","inLanguage":"en","datePublished":"2022-06-29T14:54:23+05:30","dateModified":"2022-06-29T14:54:23+05:30","mainEntityOfPage":{"@type":"WebPage","@id":"https://rv178.is-a.dev/posts/post-0/"},"publisher":{"@type":"Organization","name":"rv178","logo":{"@type":"ImageObject","url":"https://rv178.is-a.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><ul id=menu><li><a href=https://rv178.is-a.dev/ title=Home><span>Home</span></a></li><li><a href=https://rv178.is-a.dev/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://rv178.is-a.dev/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul><div class=logo><a href=https://rv178.is-a.dev accesskey=h title="rv178 (Alt + H)">rv178</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Binary Exponentiation Extended</h1><div class=post-meta><span title='2022-06-29 14:54:23 +0530 +0530'>June 29, 2022</span></div></header><div class=post-content><p>I could not find any article or blog on this idea, and felt having one could be helpful to many. There might be unwanted errors, so please feel free to to share any suggestions, corrections or concerns. For those who are unware of Binary Exponentation, <a href=https://cp-algorithms.com/algebra/binary-exp.html>this CP-Algorithms article</a> or <a href="https://youtu.be/L-Wzglnm4dM?si=VL1jTQI537JWwJ4-">this video by Errichto</a> can help get familiar with it.</p><h4 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h4><p>Now that we know the idea behind binary exponentiation; let us try expanding the idea. Say, we break the problem into two parts, $L$ and $R$, such that, once we have both the results, combining them gives us our final answer as $ans = L \odot R$, where $\odot$ is an <em>associative binary operator.</em> If we can find $R$ as a function of $L$ as in $R = f(L)$ fast enough, say $O(X)$, then our final answer can be found in $O(X \cdot log(n))$.</p><p>The idea is simple enough, so we now have a look at some simple examples. For the sake of simplicity we assume problem size $n$ is of form $2^k$ , $ k \in \mathbb{Z} $ .</p><h4 id=example-1-calculating-an><strong>Example 1:</strong> Calculating $a^n$<a hidden class=anchor aria-hidden=true href=#example-1-calculating-an>#</a></h4><p>We are starting from the simplest example. We know that $ans = \underbrace{a \cdot a \dots \cdot a \cdot a }_\text{ n times}$. If we take $R = f(L) = L$, where $L = a^{n/2}$; we can find $R$ in $O(1)$ and build our answer as -</p><p>$\newline$</p><p>$$ans = \underbrace{\underbrace{\dots \dots \dots}<em>{L} \odot \underbrace{\dots \dots \dots}</em>{R=f(L)}}<em>{L&rsquo;} \odot \underbrace{\dots \dots \dots \dots \dots \dots \dots}</em>{R` = f(L&rsquo;)} ; \odot \dots \dots$$</p><p>We are able to compute $R&rsquo;$ directly from $L&rsquo;$, unlike other methods such as RMQ or Binary Lifting where we build our answer from already calculated $L$ and $R$ on the independent smaller ranges to later combine them to compute the the answer for the bigger range.</p><p><strong>Time Complexity:</strong> Finding $R = f(L)$ is $O(1)$, so total time complexity is $O(log(n))$.</p><h5 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h5><p>The below function only works if $n$ is even. One simple way to handle the odd case is to break the expression as $a^n = a \cdot a^{n-1}$. We can get the answer for $a^{n-1}$ because it&rsquo;s even ans whether $n$ is even or odd, in $\leq 2$ steps $n$ definitely gets halved which ensures that the time complexity remains $O(log(n))$.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>binexpo</span>(<span style=color:#66d9ef>int</span> a,<span style=color:#66d9ef>int</span> n)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>return</span> a;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span>) <span style=color:#66d9ef>return</span> a <span style=color:#f92672>*</span> binexpo(a, n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// this line happen only #SetBits times as on every step n is halving
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> L <span style=color:#f92672>=</span> binexpo(a, n <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> R <span style=color:#f92672>=</span> L;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> R <span style=color:#f92672>*</span> L;    
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=example-2-summation-of-gp-series><strong>Example 2:</strong> Summation of GP Series<a hidden class=anchor aria-hidden=true href=#example-2-summation-of-gp-series>#</a></h4><p>Considering a standard GP series, we find its summation as</p><p>$\newline$</p><p>$$ans = 1 + r + r^{2} \dots r^{n-1} = \frac{r^{n}-1}{r-1}$$</p><p>If we have to find the summation under arbitrary MOD then it&rsquo;s not necessary that $(r-1)^{-1}$ exists, and so we alternatively express our sum as</p><p>$$ans = \underbrace{1 + r + r^{2} \dots r^{ \frac{n-1}{2} } }<em>\text{L} + \underbrace{r^{ \frac{n}{2} } + \dots + r^{n-1}}</em>\text{R} $$</p><p>which gives $R = f(L) = r^{\frac{n}{2}} \cdot L$.</p><p>To handle the case for odd $n$ during implementation, we can break series as</p><p>$\newline$</p><p>$$ans = 1 + a \cdot \underbrace{(1 + a + a^2 + \dots + a^{n-2})}_\text{say sum is S}$$</p><p>We can find $S$ as $(n - 1)$ is even, and final answer will be $= 1 + a \cdot S$.</p><p><strong>Time Complexity:</strong> Computing $R = f(L)$ is $O(log(n))$, so our total time complexity becomes $O(log(n)^{2})$. But we can calculate powers of $r$ along with our series, so we restrict the final time complexity to $O(log(n))$.</p><h5 id=implementation-1>Implementation<a hidden class=anchor aria-hidden=true href=#implementation-1>#</a></h5><p>Naive Approach ($O(log(n)^{2})$)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>binexpo</span>(<span style=color:#66d9ef>int</span> x,<span style=color:#66d9ef>int</span> n){<span style=color:#75715e>/* above code goes here */</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>GP</span>(<span style=color:#66d9ef>int</span> r, <span style=color:#66d9ef>int</span> n)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> r <span style=color:#f92672>*</span> GP(r, n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> L <span style=color:#f92672>=</span> GP(r, n <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> R <span style=color:#f92672>=</span> binexpo(r, n <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>*</span> L;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> L <span style=color:#f92672>+</span> R;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now, applying our optimization, we compute { $ { r^n ,1 + r \dots + r^{n-1} } $ } together for a final time complexity of $O(logn)$</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// {r^n, 1 + r + r^2 ... r^(n-1)}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> GP(<span style=color:#66d9ef>int</span> r, <span style=color:#66d9ef>int</span> n)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> {r, <span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> [x, y] <span style=color:#f92672>=</span> GP(r, n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> {r <span style=color:#f92672>*</span> x, <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> r <span style=color:#f92672>*</span> y};
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> [x, L] <span style=color:#f92672>=</span> GP(r, n <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> R <span style=color:#f92672>=</span> x <span style=color:#f92672>*</span> L;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> {x <span style=color:#f92672>*</span> x, R <span style=color:#f92672>+</span> L};
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We can use a similar idea for calculating GP series of matrices $= I + A + A^2 + \dots + A^{n-1}$. Just like integers under modulo, we can&rsquo;t always guarantee $(A-I)^{-1}$ exists.</p><p><strong>Contest Example:</strong> In <a href=https://atcoder.jp/contests/abc293/tasks/abc293_e>AtCoder ABC 293 Task E</a> the task is to just compute the sum of a GP series.</p><h4 id=example-3-summation-of-ap-gp-series><strong>Example 3:</strong> Summation of AP-GP series<a hidden class=anchor aria-hidden=true href=#example-3-summation-of-ap-gp-series>#</a></h4><p>We start by considering the simple series $\displaystyle r + 2 \cdot r^2 + 3 \cdot r^3 \dots + (n-1)\cdot r^{n-1} = \sum\limits_{i=0}^{n-1} i\cdot r^i$. For this we express the summation as below</p><p>$$ans = \underbrace{r + 2 \cdot r^2 + \dots + (\frac{n}{2}-1) \cdot r^{ \frac{n}{2}-1 }}<em>\text{L} + \underbrace{ \frac{n}{2} \cdot r^{\frac{n}{2}} + \dots + (n-1) \cdot r^{n-1}}</em>\text{R} $$</p><p>Now we solve for $R = f(L)$.</p><h5 id=solution-for-r-as-a-function-of-l>Solution for R as a function of L<a hidden class=anchor aria-hidden=true href=#solution-for-r-as-a-function-of-l>#</a></h5><p>$$R = (\frac{n}{2} + 0) \cdot r^{\frac{n}{2}} + (\frac{n}{2} + 1) \cdot r^{\frac{n}{2}+1} + \dots + (\frac{n}{2} + i) \cdot r^{\frac{n}{2}+i} + \dots + (\frac{n}{2} + \frac{n}{2}-1) \cdot r^{\frac{n}{2} + \frac{n}{2}-1}$$</p><p>$$\implies R = \frac{n}{2} \cdot \left( r^{\frac{n}{2}} + r^{\frac{n}{2}+1} + \dots + r^{\frac{n}{2}+i} + \dots + r^{n-1} \right) + r^{\frac{n}{2}} \cdot \underbrace{\left( 0 \cdot r^{0} + 1 \cdot r^{1} + \dots + i \cdot r^{i} + \dots + \left(\frac{n}{2}-1\right) \cdot r^{\frac{n}{2}-1} \right)}_{\text{L}}$$</p><p>$$\implies R = r^{\frac{n}{2}} \cdot \left( \frac{n}{2} \cdot \underbrace{\left( 1 + r^{1} + \dots + r^{i} + \dots + r^{\frac{n}{2}-1} \right)}_{\text{GP series}} + L \right)$$</p><p>We shall call this GP series as $L_{0}$, whose sum we can already calculate efficiently. Hence,</p><p>$$R = r^{\frac{n}{2}} \cdot \left( \frac{n}{2} \cdot L_{0} + L \right)$$</p><p>$$\implies R = f(L_{0},L) = r^{\frac{n}{2}} \cdot \left( \frac{n}{2} \cdot L_{0} + L \right)$$</p><p>To handle the odd case during implementation, we express summation as:</p><p>$\newline$</p><p>$$sum = r + 2\cdot r^2 + \dots + (n-1) \cdot r^{n-1}$$
$$= \left(r + r^2 + \dots + r^i + \dots + r^{n-1} \right) + \left( r^2 + 2\cdot r^3 + \dots + (i-1)\cdot r^{i-1} + \dots + (n-2)\cdot r^{n-1} \right)$$</p><p>$$= r \cdot \underbrace{\left(1 + r^1 + \dots + r^i + \dots + r^{n-2} \right)}<em>\text{X} + r \cdot \underbrace{\left( r^1 + 2\cdot r^2 + \dots + i\cdot r^{i} + \dots + (n-2)\cdot r^{n-2} \right)}</em>\text{Y}$$</p><p>We can get $X$ and $Y$ because they are of even length, and our final answer will be $= r \cdot X + r \cdot Y$ .</p><p><strong>Time Complexity:</strong> To get $R$ we need to solve $L_{0}$ which takes $O(log(n))$ so total will be $O(log(n)^2)$, but we can calculate powers of $r$, $L_{0}$ and $L$ together which makes total time $O(log(n))$.</p><h5 id=implementation-2>Implementation<a hidden class=anchor aria-hidden=true href=#implementation-2>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// {r^n , 1+r+r^2 ... + r^(n-1) , 0 + r + 2r^2 + ... + (n-1)r^(n-1) }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>&gt;</span> APGP(<span style=color:#66d9ef>int</span> r, <span style=color:#66d9ef>int</span> n)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> {r, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> [x, L0, L] <span style=color:#f92672>=</span> APGP(r, n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> {r <span style=color:#f92672>*</span> x, <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> r <span style=color:#f92672>*</span> L0, r <span style=color:#f92672>*</span> L0 <span style=color:#f92672>+</span> r <span style=color:#f92672>*</span> L};
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> [x, L0, L] <span style=color:#f92672>=</span> APGP(r, n <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> R0 <span style=color:#f92672>=</span> x <span style=color:#f92672>*</span> L0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> R <span style=color:#f92672>=</span> x <span style=color:#f92672>*</span> (n <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> L0 <span style=color:#f92672>+</span> L);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> {x <span style=color:#f92672>*</span> x, L0 <span style=color:#f92672>+</span> R0, L <span style=color:#f92672>+</span> R};
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For any generic AP-GP series $\sum_{i=0}^{n-1} ( a + i \cdot b ) \cdot r^i = a \cdot \underbrace{\sum_{i=0}^{n-1} r^i}<em>{\text{L0}} + b \cdot \underbrace{\sum</em>{i=0}^{n-1} i \cdot r^i}<em>{\text{L}} = a \cdot L</em>{0} + b \cdot L$, where both are being calculated with single function call.</p><p><a href=https://atcoder.jp/contests/abc129/tasks/abc129_f>AtCoder ABC 129 task F</a> is a good practice example for the ideas in the blog.</p><h4 id=genralising-the-above-series-summations>Genralising the above series summations<a hidden class=anchor aria-hidden=true href=#genralising-the-above-series-summations>#</a></h4><p>Now, let us consider $\displaystyle S(n,m) = ‎‎\sum\limits_{i=0}^{n-1} i^m \cdot r^i $. Then we would have GP $= S(n,0)$ and AP-GP $= S(n,1)$. Hence,</p><p>$\newline$</p><p>$$\displaystyle S(n,m) = r + 2^m \cdot r^2 + \dots + i^m \cdot r^i + \dots + (n-1)^m \cdot r^{n-1}$$</p><p>$$\displaystyle = \underbrace{r + 2^m \cdot r^2 + \dots + (\frac{n}{2}-1)^{m} \cdot r^{\frac{n}{2}-1}}<em>\text{L(m,n/2)} + \underbrace{{(\frac{n}{2}})^{m} \cdot r^{\frac{n}{2}} + \dots + (n-1)^m \cdot r^{n-1}}</em>\text{R(m,n/2)}$$</p><p>Here $L_{m,\frac{n}{2}} = S(\frac{n}{2},m)$. Then, $S(n,m) = L_{m,\frac{n}{2}} + R_{m,\frac{n}{2}}$, We need to compute $R_{m,\frac{n}{2}}$.</p><p>$\newline$</p><p>$$\displaystyle R_{m,\frac{n}{2}} = r^{\frac{n}{2}} \cdot \left( (\frac{n}{2})^m + (\frac{n}{2}+1)^m \cdot r + \dots + (\frac{n}{2} + i)^m \cdot r^i + \dots (\frac{n}{2} + \frac{n}{2} - 1)^m \cdot r^{\frac{n}{2}-1} \right)$$</p><p>$$\displaystyle R_{m,\frac{n}{2}} = r^{\frac{n}{2}} \cdot \left( \sum\limits_{i=0}^{\frac{n}{2}-1} \left( \sum\limits_{j=0}^{m} \binom{m}{j} \left(\frac{n}{2}\right)^{m-j} \cdot i^j \right) \cdot r^i \right) $$</p><p>Now, swapping the summations -</p><p>$$\displaystyle R_{m,\frac{n}{2}} = r^{\frac{n}{2}} \cdot \left( \sum\limits_{j=0}^{m} \binom{m}{j} \left( \frac{n}{2}\right) ^{m-j} \underbrace{\left( \sum\limits_{i=0}^{\frac{n}{2}-1} i^j \cdot r^i \right)}_\text{L(j,n/2)} \right) $$</p><p>Finally,</p><p>$$\displaystyle R_{m,\frac{n}{2}} = r^{\frac{n}{2}} \cdot \left( \sum\limits_{j=0}^{m} \binom{m}{j} \left( \frac{n}{2}\right) ^{m-j} \cdot L_{j,\frac{n}{2}} \right) = r^{\frac{n}{2}} \cdot \left( \sum\limits_{j=0}^{m} \binom{m}{j} \left( \frac{n}{2}\right) ^{m-j} \cdot S_{\frac{n}{2},j} \right) $$</p><p>As $j \leq m$ if we calculate everything together, just like above and hence know the value of every $L_{j,\frac{n}{2}}$ without any extra time. We can validate our results for the above illustrated examples of AP and AP-GP series.</p><h5 id=validating-our-results-against-our-previous-examples>Validating our results against our previous examples<a hidden class=anchor aria-hidden=true href=#validating-our-results-against-our-previous-examples>#</a></h5><p><strong>Case 1:</strong> for $m=0$ , which is simple GP series</p><p>$R_{0,\frac{n}{2}} = r^{\frac{n}{2}} \cdot \left( \sum\limits_{j=0}^{0} \binom{0}{j} \left( \frac{n}{2}\right) ^{0-j} \cdot L_{j,\frac{n}{2}} \right) = r^{\frac{n}{2}} \cdot L_{0,\frac{n}{2}}$</p><p><strong>Case 2:</strong> for $m=1$ , which is AP-GP series</p><p>$R_{1,\frac{n}{2}} = r^{\frac{n}{2}} \cdot \left( \sum\limits_{j=0}^{1} \binom{1}{j} \left( \frac{n}{2}\right) ^{1-j} \cdot L_{j,\frac{n}{2}} \right) = r^{\frac{n}{2}} \cdot \left( \left( \frac{n}{2}\right) ^{1} \cdot L_{0,\frac{n}{2}} + L_{1,\frac{n}{2}} \right)$</p><p>We can now evaluate our original summation as $\displaystyle S_{n,m} = S_{\frac{n}{2},m} + r^{\frac{n}{2}} \cdot \left( \sum\limits_{j=0}^{m} \binom{m}{j} \left( \frac{n}{2}\right) ^{m-j} \cdot S_{\frac{n}{2},j} \right)$.</p><h5 id=handling-odd-case>Handling Odd Case<a hidden class=anchor aria-hidden=true href=#handling-odd-case>#</a></h5><p>We have $\displaystyle S_{n,m} = \sum\limits_{i=0}^{n-1} i^m \cdot r^i = r \cdot \left( \sum\limits_{i=1}^{n-2} (i+1)^m \cdot r^i \right)$. However we can only write this if $m>0$ but for $m=0$ first term will not be $0$ but instead be $\displaystyle \lim_{x \to 0} x^x = 1$. So for $m=0$ we will add $1$ instead of $0$, keeping the remainder of the expression same. Thus</p><p>$$\displaystyle S_{n,m} = r \cdot \left( \sum\limits_{i=0}^{n-2} \sum\limits_{j=0}^{m} \binom{m}{j} i^j \cdot r^i \right)$$</p><p>And swapping summations</p><p>$$\displaystyle S_{n,m} = r \cdot \left( \sum\limits_{j=0}^{m} \binom{m}{j} \underbrace{\sum\limits_{i=0}^{n-2} i^j \cdot r^i}<em>\text{S(n-1,j)} \right) = r \cdot \left( \sum\limits</em>{j=0}^{m} \binom{m}{j} S_{n-1,j} \right) \hspace{0.25cm} \text{for} \hspace{0.25cm}m > 0$$</p><p>Hence, we have the final result as:</p><p>$$
\displaystyle
\begin{equation}
S_{n,m}=
\begin{cases}
1 + r \cdot S_{n-1,0} & \text{if } m=0\
r \cdot \left(\displaystyle \sum\limits_{j=0}^{m} \binom{m}{j} S_{n-1,j} \right) & \text{if } m > 0
\end{cases}
\end{equation}
$$</p><p>We can also construct a clean visualization of the even and odd cases using matrix multiplication instead of summation. These are illustrated as below.</p><h5 id=odd-case>Odd Case<a hidden class=anchor aria-hidden=true href=#odd-case>#</a></h5><p>Dimensions are: $(m+1,1) = (m+1,m+2) \cdot (m+2,1)$.</p><p>$$\begin{bmatrix} S_{n,0} \ S_{n,1} \ \vdots \ S_{n,m} \end{bmatrix} = \begin{bmatrix} 1 & \binom{0}{0} & 0 & 0 & \dots & 0 \ 0 & \binom{1}{0} & \binom{1}{1} & 0 & \dots & 0 \ \vdots & \vdots & \vdots & \ddots & \vdots & \vdots \ 0 & \binom{m}{0} & \binom{m}{1} & \binom{m}{2} & \dots & \binom{m}{m} \end{bmatrix} \cdot \begin{bmatrix} 1 \ r \cdot S_{n-1,0} \ r \cdot S_{n-1,1} \ \vdots \ r \cdot S_{n-1,m} \end{bmatrix}$$</p><p>We will return the array $(S_{n,0},S_{n,1}, \dots , S_{n,m}, r^n)$.</p><h5 id=even-case>Even Case<a hidden class=anchor aria-hidden=true href=#even-case>#</a></h5><p>Dimension are: $(m+1,1) = (m+1,m+1) \cdot (m+1,1)$.</p><p>$$
\begin{bmatrix}
R_{0,\frac{n}{2}} \
R_{1,\frac{n}{2}} \
\vdots \
R_{m,\frac{n}{2}}<br>\end{bmatrix}
= r^{\frac{n}{2}} \cdot
\begin{bmatrix}
\binom{0}{0} & 0 & 0 & \dots & 0 \
\binom{1}{0} \cdot \frac{n}{2} & \binom{1}{1} & 0 & \dots & 0 \
\vdots & \vdots & \vdots & \ddots & \vdots \
\binom{m}{0} \cdot \left(\frac{n}{2}\right)^m & \binom{m}{1} \cdot \left(\frac{n}{2}\right)^{m-1} & \binom{m}{2} \cdot \left(\frac{n}{2}\right)^{m-2} & \dots & \binom{m}{m}<br>\end{bmatrix}
\cdot
\begin{bmatrix}
L_{0,\frac{n}{2}} \
L_{1,\frac{n}{2}} \
L_{2,\frac{n}{2}} \
\vdots \
L_{m,\frac{n}{2}}<br>\end{bmatrix}
$$</p><p>We will return the array $(L_{0, n/2} + R_{0, n/2},L_{1, n/2} + R_{1, n/2}, \dots , L_{m, n/2} + R_{m, n/2}, r^n)$.</p><p>In the above cases, whenever we are computing values of $R_{j, n / 2} \hspace{0.25cm} \text{for} \hspace{0.25cm} j \in [0, m]$, they still indeed maintain our original form of $R = f(L)$ as we can express them as</p><p>$$\vec{R_{\frac{n}{2}}} = f(\vec{L})= r^{\frac{n}{2}} \left( M(n,m) \cdot \vec{L_{\frac{n}{2}}} \right) $$</p><p><strong>Time Complexity:</strong> To find $R_{j,\frac{n}{2}}$ takes summation of $m$ terms and we do that for every $j \leq m$ which will take $O(m^2)$. So, total complexity is $O(m^2 \cdot log(n)).$</p><h5 id=implementation-3>Implementation<a hidden class=anchor aria-hidden=true href=#implementation-3>#</a></h5><ol><li><p>Precalculation of $nCr$ takes $O(m^2)$.</p></li><li><p>During our computations, whenever we have even $n$ we need to compute $(\frac{n}{2})^j$ for each $j \leq m$, which takes $O(m \cdot log(n))$.</p></li></ol><p>Total complexity $O(m^2 + m \cdot log(n) + m^2 \cdot log(n))$ asymptotically remains same $O(m^2 \cdot log(n))$ .</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>using</span> int64 <span style=color:#f92672>=</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> MOD <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e9</span><span style=color:#f92672>+</span><span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> M<span style=color:#f92672>=</span><span style=color:#ae81ff>1002</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span>x,<span style=color:#66d9ef>int</span> y){
</span></span><span style=display:flex><span>    x<span style=color:#f92672>+=</span>y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(x<span style=color:#f92672>&gt;=</span>MOD)x<span style=color:#f92672>-=</span>MOD;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>mul</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span>x,<span style=color:#66d9ef>int</span> y){
</span></span><span style=display:flex><span>    x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1ll</span> <span style=color:#f92672>*</span> x <span style=color:#f92672>*</span> y <span style=color:#f92672>%</span> MOD;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> ncr[M][M]{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>nCr</span>(<span style=color:#66d9ef>int</span> nn,<span style=color:#66d9ef>int</span> rr){
</span></span><span style=display:flex><span> <span style=color:#66d9ef>return</span> ncr[nn][rr];   
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// Precalculate calculate n choose r in O(M^2)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>nCrinit</span>(){
</span></span><span style=display:flex><span>    ncr[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>]<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> n<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;n<span style=color:#f92672>&lt;</span>M;n<span style=color:#f92672>++</span>)ncr[n][n]<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>,ncr[n][<span style=color:#ae81ff>0</span>]<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> n<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;n<span style=color:#f92672>&lt;</span>M;n<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> r<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;r<span style=color:#f92672>&lt;</span>n;r<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            add(ncr[n][r],ncr[n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][r<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>            add(ncr[n][r],ncr[n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][r]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Precalculation of powers of n in O(M * logN)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> vt <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>map<span style=color:#f92672>&lt;</span>int64,vt<span style=color:#f92672>&gt;</span> ni;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>n_i</span>(int64 n,<span style=color:#66d9ef>int</span> i){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ni[n][i];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>n_iinit</span>(int64 n){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(n<span style=color:#f92672>&gt;</span><span style=color:#ae81ff>0</span>){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(n<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span>){
</span></span><span style=display:flex><span>            n<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        vt x(M); x[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;i<span style=color:#f92672>&lt;</span>M;i<span style=color:#f92672>++</span>)x[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1ll</span> <span style=color:#f92672>*</span> x[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> (n<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>%</span> MOD) <span style=color:#f92672>%</span> MOD;
</span></span><span style=display:flex><span>        ni[n<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>        n<span style=color:#f92672>&gt;&gt;=</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ni[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(M,<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Function to generate the series {S(n,0),S(n,1),...,S(n,m),r^n}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> Series(<span style=color:#66d9ef>int</span> r,int64 n,<span style=color:#66d9ef>int</span> m)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(n<span style=color:#f92672>==</span><span style=color:#ae81ff>1</span>){
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> a(m<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        a[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        a[m<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>=</span>r;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(n<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span>){
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Recursive case for odd n
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>a <span style=color:#f92672>=</span> Series(r,n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,m);
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> S(m<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        add(S[m<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>],<span style=color:#ae81ff>1ll</span> <span style=color:#f92672>*</span> r <span style=color:#f92672>*</span> a[m<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>%</span>MOD);
</span></span><span style=display:flex><span>        add(S[<span style=color:#ae81ff>0</span>],<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        add(S[<span style=color:#ae81ff>0</span>],<span style=color:#ae81ff>1ll</span><span style=color:#f92672>*</span>r<span style=color:#f92672>*</span>a[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>%</span>MOD);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;i<span style=color:#f92672>&lt;=</span>m;i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;j<span style=color:#f92672>&lt;=</span>i;j<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>                add(S[i], <span style=color:#ae81ff>1ll</span> <span style=color:#f92672>*</span> nCr(i,j) <span style=color:#f92672>*</span> a[j] <span style=color:#f92672>%</span> MOD);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            mul(S[i],r);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> S;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Recursive case for even n
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> L <span style=color:#f92672>=</span> Series(r,n<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>,m);
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> R(m<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;=</span>m;i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;j<span style=color:#f92672>&lt;=</span>i;j<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> h <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            mul(h,nCr(i,j));
</span></span><span style=display:flex><span>            mul(h,n_i(n<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>,i<span style=color:#f92672>-</span>j));
</span></span><span style=display:flex><span>            mul(h,L[m<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>            mul(h,L[j]);
</span></span><span style=display:flex><span>            add(R[i],h);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> S(m<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    S[m<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1ll</span> <span style=color:#f92672>*</span> L[m<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> L[m<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>%</span> MOD;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;=</span>m;i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        <span style=color:#75715e>// S[i]=(MOD + R[i] + L[i])%MOD;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        add(S[i],R[i]);
</span></span><span style=display:flex><span>        add(S[i],L[i]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> S;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>Copyright &copy; 2025 <a href=https://rv178.is-a.dev>rv178</a></span>
<span>| <a href=https://github.com/rv178/website rel=noopener target=_blank>Source code</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>