[{"content":" Welcome to my dev-blog series on writing a chess engine. This is part 3. Like always, suggestions are welcome!\nHyperbola quintessence? This is the definition from chessprogramming.org:\nHyperbola Quintessence applies the o^(o-2r)-trick also for vertical or diagonal negative Rays - by reversing the bit-order of up to one bit per rank or byte with a vertical flip aka x86-64 bswap.\nWhy did I go for this approach? Because I thought magic bitboards were too hard for me.\nImplementation // hyperbola quintessence pub fn hyp_quint(sq: Square, occ: BitBoard, mask: u64) -\u0026gt; BitBoard { let mut forward = occ.0 \u0026amp; mask; let mut reverse = forward.reverse_bits(); forward = forward.wrapping_sub(BitBoard::from_sq(sq).0); reverse = reverse.wrapping_sub(BitBoard::from_sq(sq).0.reverse_bits()); forward ^= reverse.reverse_bits(); forward \u0026amp;= mask; BitBoard(forward) } Where sq is the square the piece is in, occ is the occupancy bitboard, and mask is the attack mask. Why use wrapping_sub() instead of the -= operator? I found that the code sometimes panics if the variable is out of bounds.\nAs I already covered in my previous blog:\n// to represent squares #[rustfmt::skip] #[derive(Copy, Clone, Debug, PartialEq, Eq)] enum Square { A8, B8, C8, D8, E8, F8, G8, H8, A7, B7, C7, D7, E7, F7, G7, H7, A6, B6, C6, D6, E6, F6, G6, H6, A5, B5, C5, D5, E5, F5, G5, H5, A4, B4, C4, D4, E4, F4, G4, H4, A3, B3, C3, D3, E3, F3, G3, H3, A2, B2, C2, D2, E2, F2, G2, H2, A1, B1, C1, D1, E1, F1, G1, H1, } Square is an enum. The occupancy bitboard gives us the occupied squares (where the rays are blocked). As for the mask, here\u0026rsquo;s an example:\nLet\u0026rsquo;s say we wish to get the attacks in one file. For this, let\u0026rsquo;s assume a rook is on E4:\nHex: 1000000000 Value: 68719476736 8 . . . . . . . . 7 . . . . . . . . 6 . . . . . . . . 5 . . . . . . . . 4 . . . . 1 . . . 3 . . . . . . . . 2 . . . . . . . . 1 . . . . . . . . a b c d e f g h And C4 and G4 are occupied:\nHex: 4400000000 Value: 292057776128 8 . . . . . . . . 7 . . . . . . . . 6 . . . . . . . . 5 . . . . . . . . 4 . . 1 . . . 1 . 3 . . . . . . . . 2 . . . . . . . . 1 . . . . . . . . a b c d e f g h Now the mask for generating attack on this specific rank would be a bitboard of the 4th rank. That is,\nHex: ff00000000 Value: 1095216660480 8 . . . . . . . . 7 . . . . . . . . 6 . . . . . . . . 5 . . . . . . . . 4 1 1 1 1 1 1 1 1 3 . . . . . . . . 2 . . . . . . . . 1 . . . . . . . . a b c d e f g h Now if we execute the hyperbola quintessence function on this, we get all possible attacks for the rook on the 4th rank.\nhyp_quint(Square::E4, r, RANKS[4].0).print(); Hex: 6c00000000 Value: 463856467968 8 . . . . . . . . 7 . . . . . . . . 6 . . . . . . . . 5 . . . . . . . . 4 . . 1 1 . 1 1 . 3 . . . . . . . . 2 . . . . . . . . 1 . . . . . . . . a b c d e f g h This is the intended bitboard denoting all possible rank-attacks of a rook on E4 with respect to the occupancy bitboard. Note that we also generate an attack on the blocked bits, as they can be captures (unless they\u0026rsquo;re friendly pieces).\nWe can do the same for generating rook attacks both vertically and horizontally.\npub fn rook(sq: Square, occ: BitBoard) -\u0026gt; BitBoard { let tr = sq as usize / 8; let tf = sq as usize % 8; BitBoard(hyp_quint(sq, occ, FILES[tf].0).0 | hyp_quint(sq, occ, RANKS[tr].0).0) } Where tr is the target rank, and tf is the target file (for getting the value of file/rank mask).\npub const RANKS: [BitBoard; 8] = [ BitBoard(255), // 8th rank BitBoard(65280), // 7th rank BitBoard(16711680), // 6th rank BitBoard(4278190080), // 5th rank BitBoard(1095216660480), // 4th rank BitBoard(280375465082880), // 3rd rank BitBoard(71776119061217280), // 2nd rank BitBoard(18374686479671623680), // 1st rank ]; pub const FILES: [BitBoard; 8] = [ BitBoard(72340172838076673), // a file BitBoard(144680345676153346), // b file BitBoard(289360691352306692), // c file BitBoard(578721382704613384), // d file BitBoard(1157442765409226768), // e file BitBoard(2314885530818453536), // f file BitBoard(4629771061636907072), // g file BitBoard(9259542123273814144), // h file ]; For bishops, we can do the same but with diagonal and anti-diagonal masks.\n// diagonal masks pub const DIAG: [BitBoard; 15] = [ BitBoard(0x80), BitBoard(0x8040), BitBoard(0x804020), BitBoard(0x80402010), BitBoard(0x8040201008), BitBoard(0x804020100804), BitBoard(0x80402010080402), BitBoard(0x8040201008040201), BitBoard(0x4020100804020100), BitBoard(0x2010080402010000), BitBoard(0x1008040201000000), BitBoard(0x804020100000000), BitBoard(0x402010000000000), BitBoard(0x201000000000000), BitBoard(0x100000000000000), ]; // anti-diagonal masks pub const ANTI_DIAG: [BitBoard; 15] = [ BitBoard(0x1), BitBoard(0x102), BitBoard(0x10204), BitBoard(0x1020408), BitBoard(0x102040810), BitBoard(0x10204081020), BitBoard(0x1020408102040), BitBoard(0x102040810204080), BitBoard(0x204081020408000), BitBoard(0x408102040800000), BitBoard(0x810204080000000), BitBoard(0x1020408000000000), BitBoard(0x2040800000000000), BitBoard(0x4080000000000000), BitBoard(0x8000000000000000), ]; pub fn bishop(sq: Square, occ: BitBoard) -\u0026gt; BitBoard { let tr = sq as usize / 8; let tf = sq as usize % 8; let diag_index: usize = 7 + tr - tf; let anti_diag_index: usize = tr + tf; BitBoard( hyp_quint(sq, occ, DIAG[diag_index].0).0 | hyp_quint(sq, occ, ANTI_DIAG[anti_diag_index].0).0, ) } And for generating queen attacks, it\u0026rsquo;s even easier since we can take the union of the bishop and rook attack bitboards:\npub fn queen(sq: Square, occ: BitBoard) -\u0026gt; BitBoard { BitBoard(rook(sq, occ).0 | bishop(sq, occ).0) } That\u0026rsquo;s it for this blog, see you soon!\n","permalink":"https://rv178.is-a.dev/posts/hyperbola-quintessence-in-rust/","summary":"Welcome to my dev-blog series on writing a chess engine. This is part 3. Like always, suggestions are welcome!\nHyperbola quintessence? This is the definition from chessprogramming.org:\nHyperbola Quintessence applies the o^(o-2r)-trick also for vertical or diagonal negative Rays - by reversing the bit-order of up to one bit per rank or byte with a vertical flip aka x86-64 bswap.\nWhy did I go for this approach? Because I thought magic bitboards were too hard for me.","title":"Hyperbola Quintessence in Rust"},{"content":" Introduction Hello there! I haven\u0026rsquo;t posted in a while because I was working on my chess engine. Specifically, representing the pieces as bitboards. Now you may ask what a bitboard is. You can use bitboards to represent a chess board in a piece-centric manner. What is so special about bitboards then? Doesn\u0026rsquo;t a piece list do the same thing? Well, representing a bitboard only requires a single unsigned 64 bit integer!\nAs taken from the chessprogramming wiki:\nTo represent the board we typically need one bitboard for each piece-type and color - likely encapsulated inside a class or structure, or as an array of bitboards as part of a position object. A one-bit inside a bitboard implies the existence of a piece of this piece-type on a certain square - one to one associated by the bit-position.\nFor example, a bitboard containing all of white\u0026rsquo;s pawns in the starting position would look like this:\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1 1 1 1 1 1 1 . . . . . . . . As you can observe, the squares containing the pawns have a value of 1 and others have a value of 0. A bitboard representing a particular piece will have 1 in the squares the piece occupies and 0 in all the other squares.\nBefore proceding further, I\u0026rsquo;d like to shed light on the fact that I\u0026rsquo;m fairly new to the chess engine development scene, so all suggestions are welcome!\nImplementation I decided to go with representing all the bitboards in a single position as a struct.\n#[derive(Debug, Clone)] struct BitPos { wp: BitBoard, // white pawns wn: BitBoard, // white knights wb: BitBoard, // white bishops wr: BitBoard, // white rooks wq: BitBoard, // white queen wk: BitBoard, // white king bp: BitBoard, // black pawns bn: BitBoard, // black knights bb: BitBoard, // black bishops br: BitBoard, // black rooks bq: BitBoard, // black queen bk: BitBoard, // black king } BitBoard is a struct containing a u64.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)] struct BitBoard(pub u64); Then I wrote a simple function to generate a bitboard from my piece list array (see fen-string-parsing-in-rust)\nfn gen(pieces: \u0026amp;mut [Option\u0026lt;Piece\u0026gt;; 64], compare: char) -\u0026gt; Self { let mut bin_str = String::new(); // reverse pieces array pieces.reverse(); for piece in pieces { if let Some(piece) = piece { if !(piece.symbol == compare) { bin_str.push(\u0026#39;0\u0026#39;); } else { bin_str.push(\u0026#39;1\u0026#39;); } } else { bin_str.push(\u0026#39;0\u0026#39;); } } // convert binary string to decimal (u64) Self(u64::from_str_radix(\u0026amp;bin_str, 2).unwrap()) } And another function to print out the bitboard:\nfn print(\u0026amp;self) { println!(\u0026#34;Value: {}\u0026#34;, \u0026amp;self.0); println!(); let mut x = 8; for rank in 0..8 { print!(\u0026#34;\\x1b[34m{}\\x1b[0m \u0026#34;, x); x -= 1; for file in 0..8 { let square = rank * 8 + file; if self.0 \u0026amp; (1 \u0026lt;\u0026lt; square) \u0026gt;= 1 { print!(\u0026#34;\\x1b[1m1\\x1b[0m \u0026#34;); } else { print!(\u0026#34;\\x1b[38;5;8m0\\x1b[0m \u0026#34;); } } println!(); } println!(); println!(\u0026#34;\\x1b[34m a b c d e f g h\\x1b[0m\u0026#34;); println!(); } And some other functions for convenience:\n// generate bitboard from square fn from_sq(square: Square) -\u0026gt; Self { Self(1 \u0026lt;\u0026lt; square as u8) } // init empty bitboard fn empty() -\u0026gt; Self { Self(0) } // set bit at given square (0 -\u0026gt; 1) fn set_bit(\u0026amp;mut self, square: Square) { self.0 |= BitBoard::from_sq(square).0; } // toggle bit at given square fn toggle_bit(\u0026amp;mut self, square: Square) { self.0 ^= BitBoard::from_sq(square).0; } What fascinated me is the fact that how easy it was to perform actions on bitboards.\nI also made an enum to represent the squares (just for convenience and better code readability).\n// to represent squares #[rustfmt::skip] #[derive(Copy, Clone, Debug, PartialEq, Eq)] enum Square { A8, B8, C8, D8, E8, F8, G8, H8, A7, B7, C7, D7, E7, F7, G7, H7, A6, B6, C6, D6, E6, F6, G6, H6, A5, B5, C5, D5, E5, F5, G5, H5, A4, B4, C4, D4, E4, F4, G4, H4, A3, B3, C3, D3, E3, F3, G3, H3, A2, B2, C2, D2, E2, F2, G2, H2, A1, B1, C1, D1, E1, F1, G1, H1, } Piece attack generation I found this very interesting. I still haven\u0026rsquo;t finished working on move generation for sliding pieces at the time of writing this.\nAnyways, for generating pawn attacks, you can shift the bitboard by 7 and 9 in specific directions to achieve the desired result. That is, capturing diagonally.\nFor example:\nconst NOT_A_FILE: BitBoard = BitBoard(18374403900871474942); const NOT_H_FILE: BitBoard = BitBoard(9187201950435737471); pub fn east(board: BitBoard, colour: Colour) -\u0026gt; BitBoard { match colour { Colour::White =\u0026gt; BitBoard((board.0 \u0026gt;\u0026gt; 9) \u0026amp; NOT_H_FILE.0), Colour::Black =\u0026gt; BitBoard((board.0 \u0026lt;\u0026lt; 9) \u0026amp; NOT_A_FILE.0), Colour::Undefined =\u0026gt; exit(1), } } pub fn west(board: BitBoard, colour: Colour) -\u0026gt; BitBoard { match colour { Colour::White =\u0026gt; BitBoard((board.0 \u0026gt;\u0026gt; 7) \u0026amp; NOT_A_FILE.0), Colour::Black =\u0026gt; BitBoard((board.0 \u0026lt;\u0026lt; 7) \u0026amp; NOT_H_FILE.0), Colour::Undefined =\u0026gt; exit(1), } } I also a made a function for convenience (lookup pawn attacks for a particular square):\npub fn lookup(square: Square, colour: Colour) -\u0026gt; BitBoard { let board = BitBoard::from_sq(square); match colour { Colour::White =\u0026gt; BitBoard(east(board, Colour::White).0 | west(board, Colour::White).0), Colour::Black =\u0026gt; BitBoard(east(board, Colour::Black).0 | west(board, Colour::Black).0), Colour::Undefined =\u0026gt; exit(1), } } And another one for all pawns:\npub fn all(board: BitBoard, colour: Colour) -\u0026gt; BitBoard { match colour { Colour::White =\u0026gt; BitBoard(east(board, Colour::White).0 | west(board, Colour::White).0), Colour::Black =\u0026gt; BitBoard(east(board, Colour::Black).0 | west(board, Colour::Black).0), Colour::Undefined =\u0026gt; exit(1), } } Attacks can be generated in the same manner for knights and kings:\nKnights noNoWe noNoEa +15 +17 | | noWeWe +6 __| |__+10 noEaEa \\ / \u0026gt;0\u0026lt; __ / \\ __ soWeWe -10 | | -6 soEaEa | | -17 -15 soSoWe soSoEa const NOT_HG_FILE: BitBoard = BitBoard(4557430888798830399); const NOT_AB_FILE: BitBoard = BitBoard(18229723555195321596); pub fn no_no_east(board: BitBoard) -\u0026gt; BitBoard { BitBoard((board.0 \u0026lt;\u0026lt; 17) \u0026amp; NOT_A_FILE.0) } pub fn no_no_west(board: BitBoard) -\u0026gt; BitBoard { BitBoard((board.0 \u0026lt;\u0026lt; 15) \u0026amp; NOT_H_FILE.0) } pub fn so_so_east(board: BitBoard) -\u0026gt; BitBoard { BitBoard((board.0 \u0026gt;\u0026gt; 15) \u0026amp; NOT_A_FILE.0) } pub fn so_so_west(board: BitBoard) -\u0026gt; BitBoard { BitBoard((board.0 \u0026gt;\u0026gt; 17) \u0026amp; NOT_H_FILE.0) } pub fn no_ea_east(board: BitBoard) -\u0026gt; BitBoard { BitBoard((board.0 \u0026lt;\u0026lt; 10) \u0026amp; NOT_AB_FILE.0) } pub fn so_ea_east(board: BitBoard) -\u0026gt; BitBoard { BitBoard((board.0 \u0026gt;\u0026gt; 6) \u0026amp; NOT_AB_FILE.0) } pub fn no_we_west(board: BitBoard) -\u0026gt; BitBoard { BitBoard((board.0 \u0026lt;\u0026lt; 6) \u0026amp; NOT_HG_FILE.0) } pub fn so_we_west(board: BitBoard) -\u0026gt; BitBoard { BitBoard((board.0 \u0026gt;\u0026gt; 10) \u0026amp; NOT_HG_FILE.0) } // and then just get the union of all the other boards pub fn knight(sq: Square) -\u0026gt; BitBoard { let board = BitBoard::from_sq(sq); let no_no_east = knight::no_no_east(board); let no_no_west = knight::no_no_west(board); let so_so_east = knight::so_so_east(board); let so_so_west = knight::so_so_west(board); let no_ea_east = knight::no_ea_east(board); let so_ea_east = knight::so_ea_east(board); let no_we_west = knight::no_we_west(board); let so_we_west = knight::so_we_west(board); BitBoard( no_no_east.0 | no_no_west.0 | so_so_east.0 | so_so_west.0 | no_ea_east.0 | so_ea_east.0 | no_we_west.0 | so_we_west.0, ) } Result (knight on e4):\n8 . . . . . . . . 7 . . . . . . . . 6 . . . 1 . 1 . . 5 . . 1 . . . 1 . 4 . . . . . . . . 3 . . 1 . . . 1 . 2 . . . 1 . 1 . . 1 . . . . . . . . a b c d e f g h King // north pub fn no(board: BitBoard) -\u0026gt; BitBoard { BitBoard(board.0 \u0026lt;\u0026lt; 8) } // south pub fn so(board: BitBoard) -\u0026gt; BitBoard { BitBoard(board.0 \u0026gt;\u0026gt; 8) } // east pub fn ea(board: BitBoard) -\u0026gt; BitBoard { BitBoard((board.0 \u0026lt;\u0026lt; 1) \u0026amp; NOT_A_FILE.0) } // west pub fn we(board: BitBoard) -\u0026gt; BitBoard { BitBoard((board.0 \u0026gt;\u0026gt; 1) \u0026amp; NOT_H_FILE.0) } // north east pub fn no_ea(board: BitBoard) -\u0026gt; BitBoard { BitBoard((board.0 \u0026lt;\u0026lt; 9) \u0026amp; NOT_A_FILE.0) } // north west pub fn no_we(board: BitBoard) -\u0026gt; BitBoard { BitBoard((board.0 \u0026lt;\u0026lt; 7) \u0026amp; NOT_H_FILE.0) } // south east pub fn so_ea(board: BitBoard) -\u0026gt; BitBoard { BitBoard((board.0 \u0026gt;\u0026gt; 7) \u0026amp; NOT_A_FILE.0) } // south west pub fn so_we(board: BitBoard) -\u0026gt; BitBoard { BitBoard((board.0 \u0026gt;\u0026gt; 9) \u0026amp; NOT_H_FILE.0) } pub fn king(sq: Square) -\u0026gt; BitBoard { let board = BitBoard::from_sq(sq); let no = king::no(board); let so = king::so(board); let ea = king::ea(board); let we = king::we(board); let no_ea = king::no_ea(board); let no_we = king::no_we(board); let so_ea = king::so_ea(board); let so_we = king::so_we(board); BitBoard(no.0 | so.0 | ea.0 | we.0 | no_ea.0 | no_we.0 | so_ea.0 | so_we.0) } Result (king on e4):\n8 . . . . . . . . 7 . . . . . . . . 6 . . . . . . . . 5 . . . 1 1 1 . . 4 . . . 1 . 1 . . 3 . . . 1 1 1 . . 2 . . . . . . . . 1 . . . . . . . . a b c d e f g h That\u0026rsquo;s it for this blog, see you soon!\nReferences chessprogramming.org/Bitboards Chess engine in C ","permalink":"https://rv178.is-a.dev/posts/bitboards-in-rust/","summary":"Introduction Hello there! I haven\u0026rsquo;t posted in a while because I was working on my chess engine. Specifically, representing the pieces as bitboards. Now you may ask what a bitboard is. You can use bitboards to represent a chess board in a piece-centric manner. What is so special about bitboards then? Doesn\u0026rsquo;t a piece list do the same thing? Well, representing a bitboard only requires a single unsigned 64 bit integer!","title":"Bitboards in Rust"},{"content":" Yew Like a lot of people, I think WASM is the future. Yew is an amazing frontend framework that helps in building web apps using WASM.\nIt\u0026rsquo;s incredibly easy to use and the performance of the app is EXTREMELY fast! I\u0026rsquo;m currently re-writing Snowstry with yew.rs for the frontend (switching from NextJS). Here\u0026rsquo;s the repo link.\nYew + Tailwind Setting up yew with tailwind was very easy as well. If you don\u0026rsquo;t know what tailwind is, here\u0026rsquo;s the link to their website.\nFirst things first, we need the tailwindcss binary for compiling the output css file.\nI prefer using yarn over npm, but it\u0026rsquo;s upto you.\nyarn global add tailwindcss Now let\u0026rsquo;s setup a tailwind config file:\nmodule.exports = { content: [\u0026#34;./src/**/*.rs\u0026#34;, \u0026#34;./index.html\u0026#34;, \u0026#34;./public/css/*.css\u0026#34;], theme: {}, plugins: [], }; Directory structure:\n├── Cargo.toml +\t├── index.html (index.html in root) ├── public │ ├── css +\t│ │ ├── main.css (global css file) +\t│ │ └── out.css (output css) ├── src │ ├── components │ │ ├── mod.rs │ │ ├── nav.rs │ ├── main.rs │ └── pages │ ├── home.rs │ ├── mod.rs │ └── notfound.rs +\t├── tailwind.config.js (tailwind config) └── Trunk.toml Now in our Trunk.toml, we setup a hook that executes before build, so output css is compiled automatically.\n[[hooks]] stage = \u0026#34;pre_build\u0026#34; command = \u0026#34;tailwindcss\u0026#34; command_arguments = [\u0026#34;-c\u0026#34;, \u0026#34;./tailwind.config.js\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;./public/css/out.css\u0026#34;, \u0026#34;--minify\u0026#34;] Now in your index.html (at the root of your project), link the output css file.\n\u0026lt;link data-trunk rel=\u0026#34;css\u0026#34; href=\u0026#34;public/css/out.css\u0026#34; /\u0026gt; Run trunk serve and you\u0026rsquo;re done! That\u0026rsquo;s it for this blog, see you soon.\n","permalink":"https://rv178.is-a.dev/posts/yew-rs-with-tailwind/","summary":"Yew Like a lot of people, I think WASM is the future. Yew is an amazing frontend framework that helps in building web apps using WASM.\nIt\u0026rsquo;s incredibly easy to use and the performance of the app is EXTREMELY fast! I\u0026rsquo;m currently re-writing Snowstry with yew.rs for the frontend (switching from NextJS). Here\u0026rsquo;s the repo link.\nYew + Tailwind Setting up yew with tailwind was very easy as well. If you don\u0026rsquo;t know what tailwind is, here\u0026rsquo;s the link to their website.","title":"Yew.rs With TailwindCSS"},{"content":" Hello! 11 days ago I switched from x11 to wayland, because 60 FPS scrolling is a feature too good to miss.\nNow what is wayland, you may ask? Wayland is like a replacement to the traditional x11 display protocol. You can read more about it here.\nMy x11 setup consisted of the following software:\nDWM as the window manager. Polybar as the status bar. Dunst as the notification daemon. ST as my terminal emulator. Betterlockscreen as the lockscreen. Rofi as the app launcher. Now before switching to wayland, some of these tools listed above straight up break in a wayland environment, like betterlockscreen and rofi. ST also behaves weirdly on wayland, but it works. And of course, since DWM is an x11 window manager, you cannot use it on wayland.\nChoosing a compositor Sway was an awesome choice, but I didn\u0026rsquo;t really like the i3-ish aspect of it.\nSo I was looking for something more DWM-like.\nRiver was a great replacement.\nChoosing a bar There are other alternatives like yambar, but I chose waybar.\nNotification daemon While dunst works in wayland, I opted for a notification daemon called mako instead.\nTerminal emulator ST was a great option, but I had to part ways with it. I switched to the foot terminal instead.\nLock screen Since betterlockscreen does not work on wayland, I chose swaylock for the lock screen.\nApplication launcher I use rofi-lbonn-git for the app launcher.\nMy setup You can find my dotfiles here.\nThat\u0026rsquo;s it for this blog see you soon!\n","permalink":"https://rv178.is-a.dev/posts/switching-to-wayland/","summary":"Hello! 11 days ago I switched from x11 to wayland, because 60 FPS scrolling is a feature too good to miss.\nNow what is wayland, you may ask? Wayland is like a replacement to the traditional x11 display protocol. You can read more about it here.\nMy x11 setup consisted of the following software:\nDWM as the window manager. Polybar as the status bar. Dunst as the notification daemon. ST as my terminal emulator.","title":"Switching to Wayland"},{"content":" After using GNU Make for automating the build step in my projects, I had this idea of making my own build automation tool like Make.\nI originally wanted to use Makefile-like syntax for the config file but instead settled with TOML after thinking about it for a while. I also used Rust to write this since I am kinda familiar with the language.\nRust has a TOML crate for parsing TOML files. It also provides support for deserialization and serialization using serde.\nIt\u0026rsquo;s also extremely easy to use:\n// we store custom and pre as HashMap\u0026lt;String, Struct\u0026gt; so that in the TOML file we can use dynamic table names. // for environment variables, it\u0026#39;s stored as HashMap\u0026lt;String, String\u0026gt; so we can specify as many env vars as we like. #[derive(Debug, Deserialize)] struct Recipe { build: Build, custom: Option\u0026lt;HashMap\u0026lt;String, Custom\u0026gt;\u0026gt;, // custom commands pre: Option\u0026lt;HashMap\u0026lt;String, Pre\u0026gt;\u0026gt;, // pre-build commands env: Option\u0026lt;HashMap\u0026lt;String, String\u0026gt;\u0026gt;, // for environment vars } /* \u0026lt;the build, custom and pre structs\u0026gt; */ let recipe: Recipe; match toml::from_str(\u0026amp;recipe_str) { Ok(r) =\u0026gt; recipe = r, Err(e) =\u0026gt; { printb!(\u0026#34;Error: {}\u0026#34;, e); exit(1); } } I didn\u0026rsquo;t include the other structs to make the snippet smaller. This was also the first time I used rust macros in a project, as you can see with the printb! macro. All it does is print Baker: \u0026lt;message\u0026gt; as coloured output.\n#[macro_export] macro_rules! printb { ($($arg:tt)*) =\u0026gt; { println!(\u0026#34;\\x1b[32mBaker:\\x1b[0m {}\u0026#34;, format!($($arg)*)); }; } Configuring baker The configuration file is put in the root directory of the project, just like the Makefile. If Baker is unable to find a config file (called recipe.toml), it auto generates one. Here\u0026rsquo;s an example config:\n[env] BIN_NAME=\u0026#34;bake\u0026#34; COMPILER_FLAGS=\u0026#34;--release\u0026#34; INSTALL_PREFIX=\u0026#34;/usr/bin\u0026#34; [build] cmd = \u0026#34;\u0026#34;\u0026#34; cargo build $COMPILER_FLAGS \u0026amp;\u0026amp; cp -r ./target/release/$BIN_NAME ./bin/$BIN_NAME \u0026#34;\u0026#34;\u0026#34; [custom.clean] cmd = \u0026#34;cargo clean\u0026#34; run = false [pre.fmt] cmd = \u0026#34;cargo fmt\u0026#34; Baker is invoked using bake and by default checks for the build field in the recipe.toml. The cmd value is then executed during build.\nYou can set environment variables using the env field.\nYou can also add custom fields using custom. It also checks for a run value that is used to check whether the command should be run after build or not. So if run = true, then the command is run after build.\nBaker also checks for an optional pre field that contains commands which should be run before build. Like for example, if you wish to format your code or something before compiling.\nYou may have noticed a name value in the custom and pre fields ([custom.name]). This is used to identify each field, and for the custom field, the name is set as an argument when Baker is invoked.\nFor example, if I have a custom field called setup:\n[custom.setup] cmd = \u0026#34;mkdir -p bin \u0026amp;\u0026amp; rustup install stable \u0026amp;\u0026amp; rustup default stable\u0026#34; run = false You can run bake setup to directly execute the command inside the field.\nBaker is open source and you can find the repo here. I wrote it in like 2 days, so it may have bugs which I was not able to find, so all suggestions are welcome!\nThat\u0026rsquo;s it for this blog, see you soon!\n","permalink":"https://rv178.is-a.dev/posts/writing-a-build-automation-tool/","summary":"After using GNU Make for automating the build step in my projects, I had this idea of making my own build automation tool like Make.\nI originally wanted to use Makefile-like syntax for the config file but instead settled with TOML after thinking about it for a while. I also used Rust to write this since I am kinda familiar with the language.\nRust has a TOML crate for parsing TOML files.","title":"Writing a Build Automation Tool"},{"content":" I finally finished the FEN string parsing part of my chess engine after days of procrastinating and I just wanted to share my experience with everyone.\nSo a FEN string looks like this:\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 This is the FEN string of the starting position in standard chess. It looks like random crap at first glance but this string conveys a lot of information.\nSo let\u0026rsquo;s divide it into parts.\nPieces The first part conveys information regarding piece placement. Each letter represents a piece on each rank of the board, and numbers denote empty spaces.\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR Let\u0026rsquo;s look at an example from chess.com here:\nAs you can observe lower case characters are for black pieces and upper case characters are for white pieces.\nNow, moving on to the second part.\nSide to move The second part consists of just a letter which can either be b or w.\nHere we can observe that it\u0026rsquo;s w.\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR | w | KQkq | - | 0 | 1 That means it\u0026rsquo;s white\u0026rsquo;s turn to move, and b means it\u0026rsquo;s black\u0026rsquo;s turn to move.\nCastling ability The third part contains information regarding castling ability of both sides.\nK - White can castle kingside.\nk - Black can castle kingside.\nQ - White can castle queenside.\nq - Black can castle queenside.\nIf no sides can castle, - is used like so:\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w - - 0 1 En passant squares The next part gives us information if any en passant squares are possible. If there are no en passant squares, - is used as demonstrated in this example. If there are any, then the co-ordinates of that square is used.\nHalf move clock and full move counter The next two parts give us information regarding the number of halfmoves and fullmoves completed. Here you can observe the half move count is 0 and the full move count is 1.\nParsing the string To track the current game status, I made a struct called GameStatus.\npub struct GameStatus { pub pieces: Vec\u0026lt;Option\u0026lt;Piece\u0026gt;\u0026gt;, pub side_to_move: Colour, pub castling_id: [bool; 4], pub en_passant: Option\u0026lt;Vec\u0026lt;Square\u0026gt;\u0026gt;, pub half_move_clock: u32, pub full_move_count: u32, } What I wanted to do here was make functions for each variable and then assign it to the fields in the struct.\nFor parsing the side to move I first created an enumerator called Colour.\npub enum Colour { White, Black, Undefined, } White and Black are both sides, and undefined is used for error handling if the input is invalid.\nI then created a function that will return a value based on the input given. I really love rust\u0026rsquo;s match syntax 😄.\nfn active_side(input: \u0026amp;str) -\u0026gt; Colour { match input { \u0026#34;w\u0026#34; =\u0026gt; Colour::White, \u0026#34;b\u0026#34; =\u0026gt; Colour::Black, _ =\u0026gt; Colour::Undefined, } } if colour == Colour::Undefined { println!(\u0026#34;Invalid FEN string: Failed to parse active colour.\u0026#34;); exit(1); } For parsing castling ability I decided to make an array of bools that would contain values corresponding to the info parsed from the string.\n[true, true, true, true] if input is KQkq (all sides can castle both ways).\nIndex 0 checks if the white king can castle kingside. ie, K and so on.\nIndex 1 =\u0026gt; can white king castle queenside?\nIndex 2 =\u0026gt; can black king castle kingside?\nIndex 3 =\u0026gt; can black king castle queenside?\nSo I made a function that returns this array of bools.\nfn castling_ability(input: \u0026amp;str) -\u0026gt; [bool; 4] { if input == \u0026#34;-\u0026#34; { [false, false, false, false] } else { let mut castling_id = [false; 4]; let mut castling_id_str = input.to_string(); castling_id_str.retain(|c| c != \u0026#39;-\u0026#39;); for c in castling_id_str.chars() { match c { \u0026#39;K\u0026#39; =\u0026gt; castling_id[0] = true, \u0026#39;Q\u0026#39; =\u0026gt; castling_id[1] = true, \u0026#39;k\u0026#39; =\u0026gt; castling_id[2] = true, \u0026#39;q\u0026#39; =\u0026gt; castling_id[3] = true, _ =\u0026gt; { println!(\u0026#34;Invalid FEN string: Failed to parse castling ability.\u0026#34;); exit(1); } } } castling_id } } For parsing en passant squares the solution I came up with was rather stupid.\nSince the input can either be - or multiple squares like e4e5g6 etc., I wanted a vector that contained each square.\nSo basically,\ne4e5g6 =\u0026gt; [Square::E4, Square::E5, Square::G6]\n(Square is an enum, this change was made later. Check this blog for more info. Yes, I updated this blog :D)\nfn en_passant(input: \u0026amp;str) -\u0026gt; Option\u0026lt;Vec\u0026lt;Square\u0026gt;\u0026gt; { if input.chars().all(char::is_whitespace) | input.contains(\u0026#39;-\u0026#39;) { None } else { let chars = input.chars().collect::\u0026lt;Vec\u0026lt;char\u0026gt;\u0026gt;(); if chars.len() % 2 == 0 { let mut ep_vec = Vec::new(); let mut sq; for i in 0..chars.len() { if i % 2 == 0 { let valid_chars = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;h\u0026#39;]; let mut invalid = true; for c in valid_chars.iter() { if chars[i] == *c { invalid = false; } } if i \u0026lt; chars.len() - 1 { if !chars[i].is_alphabetic() | !chars[i + 1].is_numeric() { fen_log!(\u0026#34;Invalid FEN string: Failed to parse en passant square.\u0026#34;); exit(1); } if chars[i + 1] .to_digit(10) .expect(\u0026#34;Could not parse character to digit (en passant)\u0026#34;) \u0026gt; 8 { invalid = true; } } if invalid { fen_log!(\u0026#34;Invalid FEN string: Failed to parse en passant square.\u0026#34;); exit(1); } let file; match chars[i] { \u0026#39;a\u0026#39; =\u0026gt; file = 0, \u0026#39;b\u0026#39; =\u0026gt; file = 1, \u0026#39;c\u0026#39; =\u0026gt; file = 2, \u0026#39;d\u0026#39; =\u0026gt; file = 3, \u0026#39;e\u0026#39; =\u0026gt; file = 4, \u0026#39;f\u0026#39; =\u0026gt; file = 5, \u0026#39;g\u0026#39; =\u0026gt; file = 6, \u0026#39;h\u0026#39; =\u0026gt; file = 7, _ =\u0026gt; { fen_log!(\u0026#34;Invalid FEN string: Failed to parse en passant square.\u0026#34;); exit(1); } } let rank; match chars[i + 1] { \u0026#39;1\u0026#39; =\u0026gt; rank = 7, \u0026#39;2\u0026#39; =\u0026gt; rank = 6, \u0026#39;3\u0026#39; =\u0026gt; rank = 5, \u0026#39;4\u0026#39; =\u0026gt; rank = 4, \u0026#39;5\u0026#39; =\u0026gt; rank = 3, \u0026#39;6\u0026#39; =\u0026gt; rank = 2, \u0026#39;7\u0026#39; =\u0026gt; rank = 1, \u0026#39;8\u0026#39; =\u0026gt; rank = 0, _ =\u0026gt; { fen_log!(\u0026#34;Invalid FEN string: Failed to parse en passant square.\u0026#34;); exit(1); } } sq = rank * 8 + file; ep_vec.push(match_u32_to_sq(sq as u32)); } } Some(ep_vec) } else { fen_log!(\u0026#34;Invalid FEN string: Failed to parse en passant square.\u0026#34;); exit(1); } } } Parsing the halfmove and fullmove counts were rather easy, and I just had to return a u32 from the string input.\nfn halfmove_clock(input: \u0026amp;str) -\u0026gt; u32 { let mut halfmove_clock = String::new(); for c in input.chars() { if c.is_digit(10) { halfmove_clock.push(c); } } halfmove_clock.parse::\u0026lt;u32\u0026gt;().unwrap() } fn fullmove_count(input: \u0026amp;str) -\u0026gt; u32 { let mut fullmove_clock = String::new(); for c in input.chars() { if c.is_digit(10) { fullmove_clock.push(c); } } fullmove_clock.parse::\u0026lt;u32\u0026gt;().unwrap() } However for piece placement parsing, I saw a really good implementation of it in the fen crate so I decided to just joink it 😔.\nThere\u0026rsquo;s a struct called Piece that stores the type, colour and symbol (added by me to print out pieces in the board).\npub struct Piece { pub kind: Kind, pub colour: Colour, pub symbol: char, } And an enum Kind:\npub enum Kind { King, Queen, Bishop, Knight, Rook, Pawn, } And according to the input given, a value is returned that is later pushed to a vector.\nlet (color, kind, symbol) = match piece_char { \u0026#39;P\u0026#39; =\u0026gt; (Colour::White, Kind::Pawn, \u0026#39;P\u0026#39;), \u0026#39;N\u0026#39; =\u0026gt; (Colour::White, Kind::Knight, \u0026#39;N\u0026#39;), \u0026#39;B\u0026#39; =\u0026gt; (Colour::White, Kind::Bishop, \u0026#39;B\u0026#39;), \u0026#39;R\u0026#39; =\u0026gt; (Colour::White, Kind::Rook, \u0026#39;R\u0026#39;), \u0026#39;Q\u0026#39; =\u0026gt; (Colour::White, Kind::Queen, \u0026#39;Q\u0026#39;), \u0026#39;K\u0026#39; =\u0026gt; (Colour::White, Kind::King, \u0026#39;K\u0026#39;), \u0026#39;p\u0026#39; =\u0026gt; (Colour::Black, Kind::Pawn, \u0026#39;p\u0026#39;), \u0026#39;n\u0026#39; =\u0026gt; (Colour::Black, Kind::Knight, \u0026#39;n\u0026#39;), \u0026#39;b\u0026#39; =\u0026gt; (Colour::Black, Kind::Bishop, \u0026#39;b\u0026#39;), \u0026#39;r\u0026#39; =\u0026gt; (Colour::Black, Kind::Rook, \u0026#39;r\u0026#39;), \u0026#39;q\u0026#39; =\u0026gt; (Colour::Black, Kind::Queen, \u0026#39;q\u0026#39;), \u0026#39;k\u0026#39; =\u0026gt; (Colour::Black, Kind::King, \u0026#39;k\u0026#39;), _ =\u0026gt; return None, }; You can check out the crate\u0026rsquo;s code for more info.\nI want to write my own implementation too but I\u0026rsquo;m too lazy and it just works.\nI also decided to add this function to print out the game state. So basically what I did was:\npub fn print_board(game_state: \u0026amp;GameStatus) { let mut board: Vec\u0026lt;char\u0026gt; = Vec::new(); for piece in game_state.pieces { if piece == None { board.push(\u0026#39; \u0026#39;); } else { board.push(piece.as_ref().unwrap().symbol); } } let mut x = 8; println!(\u0026#34;+---+---+---+---+---+---+---+---+\u0026#34;); for rank in 0..8 { x -= 1; for file in 0..8 { let square = rank * 8 + file; if board[square] == \u0026#39; \u0026#39; { print!(\u0026#34;| \u0026#34;); } else { print!(\u0026#34;| {} \u0026#34;, board[square]); } } print!(\u0026#34;| {} \\n\u0026#34;, x + 1); println!(\u0026#34;+---+---+---+---+---+---+---+---+\u0026#34;); } println!(\u0026#34; a b c d e f g h \\n\u0026#34;); } Input: rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/PNBQKB1R b KQkq - 1 2\nOutput:\n+---+---+---+---+---+---+---+---+ | r | n | b | q | k | b | n | r | 8 +---+---+---+---+---+---+---+---+ | p | p | | p | p | p | p | p | 7 +---+---+---+---+---+---+---+---+ | | | | | | | | | 6 +---+---+---+---+---+---+---+---+ | | | p | | | | | | 5 +---+---+---+---+---+---+---+---+ | | | | | P | | | | 4 +---+---+---+---+---+---+---+---+ | | | | | | N | | | 3 +---+---+---+---+---+---+---+---+ | P | P | P | P | | P | P | P | 2 +---+---+---+---+---+---+---+---+ | P | N | B | Q | K | B | | R | 1 +---+---+---+---+---+---+---+---+ a b c d e f g h Anyways that\u0026rsquo;s it for this blog see you soon 👋.\n","permalink":"https://rv178.is-a.dev/posts/fen-string-parsing-in-rust/","summary":"I finally finished the FEN string parsing part of my chess engine after days of procrastinating and I just wanted to share my experience with everyone.\nSo a FEN string looks like this:\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 This is the FEN string of the starting position in standard chess. It looks like random crap at first glance but this string conveys a lot of information.\nSo let\u0026rsquo;s divide it into parts.","title":"FEN String Parsing in Rust"},{"content":" So hi! I have been using Linux for almost 5 months now and I have learned a lot! Just wanted to share my experience with everyone.\nWhen I asked my friend (who is an expert in Linux), he recommended me Pop!_OS, an Ubuntu based distro. So, I installed it and it was my first Linux distribution. My experience using Pop!_OS was amazing and it still is one of my favourite distributions.\nWhile Linux seemed harder due to the frequent interaction with the command line, I had a bit of experience using it before (when using WSL). So the initial switch wasn\u0026rsquo;t that hard for me. I was still dual booting Windows with Pop!_OS during this time, and was still a Linux amateur.\nThings started to change when I came to know of Arch Linux, a lightweight distribution. I started reading the Arch wiki, and soon installed it on bare metal (after a bit of bullying ahem), triple booting Windows, Pop!_OS and Arch.\nAnd I ABSOLUTELY loved it. I deleted my Pop!_OS partition a while later, and Arch became my primary OS. It was a great way to learn more about Linux and its components. The first desktop environment I used with Arch, was KDE Plasma.\nWhile I certainly liked the desktop environment, I soon switched to a tiling window manager called i3. After using i3 for a few hours, I realised it wasn\u0026rsquo;t the best option for me, and switched back to KDE Plasma. A few days later I installed BSPWM, and I liked it a lot. Inspired from a friend, I installed some of his configs and modified them according to my needs.\nUsing a tiling window manager at first was a bit difficult. But soon, I started relying more on my keyboard than my mouse, switching out code editors like VS code for (Neo)Vim and relying on keyboard shortcuts for my system. Around this time, I had an idea of setting up my dotfiles repo, and I made one. Initially it was just my friend\u0026rsquo;s dotfiles, but modified according to my needs, but soon I started writing my own configs and then published the repo.\nMy BSPWM config now:\nSoon, I switched to DWM and I have been using it ever since. It\u0026rsquo;s my favourite tiling window manager. The level of extensibility it provides is just amazing! Sometimes patching DWM (as well as other suckless utilities) can be a bit tedious though.\n","permalink":"https://rv178.is-a.dev/posts/my-linux-journey/","summary":"So hi! I have been using Linux for almost 5 months now and I have learned a lot! Just wanted to share my experience with everyone.\nWhen I asked my friend (who is an expert in Linux), he recommended me Pop!_OS, an Ubuntu based distro. So, I installed it and it was my first Linux distribution. My experience using Pop!_OS was amazing and it still is one of my favourite distributions.","title":"A brief recap of my Linux journey up until now"}]